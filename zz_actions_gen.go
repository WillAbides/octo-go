// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
ActionsAddSelectedRepoToOrgSecret performs requests for "actions/add-selected-repo-to-org-secret"

Add selected repository to an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
func (c *Client) ActionsAddSelectedRepoToOrgSecret(ctx context.Context, req *ActionsAddSelectedRepoToOrgSecretReq, opt ...RequestOption) (*ActionsAddSelectedRepoToOrgSecretResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsAddSelectedRepoToOrgSecretResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsAddSelectedRepoToOrgSecretReq is request data for Client.ActionsAddSelectedRepoToOrgSecret

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
type ActionsAddSelectedRepoToOrgSecretReq struct {
	pgURL        string
	Org          string
	SecretName   string
	RepositoryId int64
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories/%v", r.Org, r.SecretName, r.RepositoryId)
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) method() string {
	return "PUT"
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) body() interface{} {
	return nil
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) validStatuses() []int {
	return []int{204}
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsAddSelectedRepoToOrgSecretReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsAddSelectedRepoToOrgSecretReq) Rel(link RelName, resp *ActionsAddSelectedRepoToOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsAddSelectedRepoToOrgSecretResponse is a response for ActionsAddSelectedRepoToOrgSecret

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
type ActionsAddSelectedRepoToOrgSecretResponse struct {
	response
	request *ActionsAddSelectedRepoToOrgSecretReq
}

/*
ActionsCancelWorkflowRun performs requests for "actions/cancel-workflow-run"

Cancel a workflow run.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
func (c *Client) ActionsCancelWorkflowRun(ctx context.Context, req *ActionsCancelWorkflowRunReq, opt ...RequestOption) (*ActionsCancelWorkflowRunResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsCancelWorkflowRunResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCancelWorkflowRunReq is request data for Client.ActionsCancelWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
type ActionsCancelWorkflowRunReq struct {
	pgURL string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsCancelWorkflowRunReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsCancelWorkflowRunReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/cancel", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsCancelWorkflowRunReq) method() string {
	return "POST"
}

func (r *ActionsCancelWorkflowRunReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCancelWorkflowRunReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCancelWorkflowRunReq) body() interface{} {
	return nil
}

func (r *ActionsCancelWorkflowRunReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsCancelWorkflowRunReq) validStatuses() []int {
	return []int{202}
}

func (r *ActionsCancelWorkflowRunReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsCancelWorkflowRunReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCancelWorkflowRunReq) Rel(link RelName, resp *ActionsCancelWorkflowRunResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsCancelWorkflowRunResponse is a response for ActionsCancelWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
type ActionsCancelWorkflowRunResponse struct {
	response
	request *ActionsCancelWorkflowRunReq
}

/*
ActionsCreateOrUpdateOrgSecret performs requests for "actions/create-or-update-org-secret"

Create or update an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
func (c *Client) ActionsCreateOrUpdateOrgSecret(ctx context.Context, req *ActionsCreateOrUpdateOrgSecretReq, opt ...RequestOption) (*ActionsCreateOrUpdateOrgSecretResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsCreateOrUpdateOrgSecretResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateOrUpdateOrgSecretReq is request data for Client.ActionsCreateOrUpdateOrgSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type ActionsCreateOrUpdateOrgSecretReq struct {
	pgURL       string
	Org         string
	SecretName  string
	RequestBody ActionsCreateOrUpdateOrgSecretReqBody
}

func (r *ActionsCreateOrUpdateOrgSecretReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsCreateOrUpdateOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName)
}

func (r *ActionsCreateOrUpdateOrgSecretReq) method() string {
	return "PUT"
}

func (r *ActionsCreateOrUpdateOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateOrUpdateOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateOrUpdateOrgSecretReq) body() interface{} {
	return r.RequestBody
}

func (r *ActionsCreateOrUpdateOrgSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsCreateOrUpdateOrgSecretReq) validStatuses() []int {
	return []int{201, 204}
}

func (r *ActionsCreateOrUpdateOrgSecretReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsCreateOrUpdateOrgSecretReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateOrUpdateOrgSecretReq) Rel(link RelName, resp *ActionsCreateOrUpdateOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsCreateOrUpdateOrgSecretReqBody is a request body for actions/create-or-update-org-secret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type ActionsCreateOrUpdateOrgSecretReqBody struct {

	/*
	   Value for your secret, encrypted with
	   [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using
	   the public key retrieved from the [Get an organization public
	   key](https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key)
	   endpoint.
	*/
	EncryptedValue *string `json:"encrypted_value,omitempty"`

	// ID of the key you used to encrypt the secret.
	KeyId *string `json:"key_id,omitempty"`

	/*
	   An array of repository ids that can access the organization secret. You can only
	   provide a list of repository ids when the `visibility` is set to `selected`. You
	   can manage the list of selected repositories using the [List selected
	   repositories for an organization
	   secret](https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret),
	   [Set selected repositories for an organization
	   secret](https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret),
	   and [Remove selected repository from an organization
	   secret](https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret)
	   endpoints.
	*/
	SelectedRepositoryIds []string `json:"selected_repository_ids,omitempty"`

	/*
	   Configures the access that repositories have to the organization secret. Can be
	   one of:
	   \- `all` - All repositories in an organization can access the secret.
	   \- `private` - Private repositories in an organization can access the secret.
	   \- `selected` - Only specific repositories can access the secret.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ActionsCreateOrUpdateOrgSecretResponse is a response for ActionsCreateOrUpdateOrgSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type ActionsCreateOrUpdateOrgSecretResponse struct {
	response
	request *ActionsCreateOrUpdateOrgSecretReq
}

/*
ActionsCreateOrUpdateRepoSecret performs requests for "actions/create-or-update-repo-secret"

Create or update a repository secret.

  PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
func (c *Client) ActionsCreateOrUpdateRepoSecret(ctx context.Context, req *ActionsCreateOrUpdateRepoSecretReq, opt ...RequestOption) (*ActionsCreateOrUpdateRepoSecretResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsCreateOrUpdateRepoSecretResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateOrUpdateRepoSecretReq is request data for Client.ActionsCreateOrUpdateRepoSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type ActionsCreateOrUpdateRepoSecretReq struct {
	pgURL       string
	Owner       string
	Repo        string
	SecretName  string
	RequestBody ActionsCreateOrUpdateRepoSecretReqBody
}

func (r *ActionsCreateOrUpdateRepoSecretReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsCreateOrUpdateRepoSecretReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName)
}

func (r *ActionsCreateOrUpdateRepoSecretReq) method() string {
	return "PUT"
}

func (r *ActionsCreateOrUpdateRepoSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateOrUpdateRepoSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateOrUpdateRepoSecretReq) body() interface{} {
	return r.RequestBody
}

func (r *ActionsCreateOrUpdateRepoSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsCreateOrUpdateRepoSecretReq) validStatuses() []int {
	return []int{201, 204}
}

func (r *ActionsCreateOrUpdateRepoSecretReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsCreateOrUpdateRepoSecretReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateOrUpdateRepoSecretReq) Rel(link RelName, resp *ActionsCreateOrUpdateRepoSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsCreateOrUpdateRepoSecretReqBody is a request body for actions/create-or-update-repo-secret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type ActionsCreateOrUpdateRepoSecretReqBody struct {

	/*
	   Value for your secret, encrypted with
	   [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using
	   the public key retrieved from the [Get a repository public
	   key](https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key)
	   endpoint.
	*/
	EncryptedValue *string `json:"encrypted_value,omitempty"`

	// ID of the key you used to encrypt the secret.
	KeyId *string `json:"key_id,omitempty"`
}

/*
ActionsCreateOrUpdateRepoSecretResponse is a response for ActionsCreateOrUpdateRepoSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type ActionsCreateOrUpdateRepoSecretResponse struct {
	response
	request *ActionsCreateOrUpdateRepoSecretReq
}

/*
ActionsCreateRegistrationTokenForOrg performs requests for "actions/create-registration-token-for-org"

Create a registration token for an organization.

  POST /orgs/{org}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
func (c *Client) ActionsCreateRegistrationTokenForOrg(ctx context.Context, req *ActionsCreateRegistrationTokenForOrgReq, opt ...RequestOption) (*ActionsCreateRegistrationTokenForOrgResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsCreateRegistrationTokenForOrgResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsCreateRegistrationTokenForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRegistrationTokenForOrgReq is request data for Client.ActionsCreateRegistrationTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
type ActionsCreateRegistrationTokenForOrgReq struct {
	pgURL string
	Org   string
}

func (r *ActionsCreateRegistrationTokenForOrgReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsCreateRegistrationTokenForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners/registration-token", r.Org)
}

func (r *ActionsCreateRegistrationTokenForOrgReq) method() string {
	return "POST"
}

func (r *ActionsCreateRegistrationTokenForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateRegistrationTokenForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateRegistrationTokenForOrgReq) body() interface{} {
	return nil
}

func (r *ActionsCreateRegistrationTokenForOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRegistrationTokenForOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRegistrationTokenForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsCreateRegistrationTokenForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRegistrationTokenForOrgReq) Rel(link RelName, resp *ActionsCreateRegistrationTokenForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsCreateRegistrationTokenForOrgResponseBody is a response body for ActionsCreateRegistrationTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
type ActionsCreateRegistrationTokenForOrgResponseBody struct {
	components.AuthenticationToken
}

/*
ActionsCreateRegistrationTokenForOrgResponse is a response for ActionsCreateRegistrationTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
type ActionsCreateRegistrationTokenForOrgResponse struct {
	response
	request *ActionsCreateRegistrationTokenForOrgReq
	Data    *ActionsCreateRegistrationTokenForOrgResponseBody
}

/*
ActionsCreateRegistrationTokenForRepo performs requests for "actions/create-registration-token-for-repo"

Create a registration token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
func (c *Client) ActionsCreateRegistrationTokenForRepo(ctx context.Context, req *ActionsCreateRegistrationTokenForRepoReq, opt ...RequestOption) (*ActionsCreateRegistrationTokenForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsCreateRegistrationTokenForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsCreateRegistrationTokenForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRegistrationTokenForRepoReq is request data for Client.ActionsCreateRegistrationTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
type ActionsCreateRegistrationTokenForRepoReq struct {
	pgURL string
	Owner string
	Repo  string
}

func (r *ActionsCreateRegistrationTokenForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsCreateRegistrationTokenForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners/registration-token", r.Owner, r.Repo)
}

func (r *ActionsCreateRegistrationTokenForRepoReq) method() string {
	return "POST"
}

func (r *ActionsCreateRegistrationTokenForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateRegistrationTokenForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateRegistrationTokenForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsCreateRegistrationTokenForRepoReq) dataStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRegistrationTokenForRepoReq) validStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRegistrationTokenForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsCreateRegistrationTokenForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRegistrationTokenForRepoReq) Rel(link RelName, resp *ActionsCreateRegistrationTokenForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsCreateRegistrationTokenForRepoResponseBody is a response body for ActionsCreateRegistrationTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
type ActionsCreateRegistrationTokenForRepoResponseBody struct {
	components.AuthenticationToken
}

/*
ActionsCreateRegistrationTokenForRepoResponse is a response for ActionsCreateRegistrationTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
type ActionsCreateRegistrationTokenForRepoResponse struct {
	response
	request *ActionsCreateRegistrationTokenForRepoReq
	Data    *ActionsCreateRegistrationTokenForRepoResponseBody
}

/*
ActionsCreateRemoveTokenForOrg performs requests for "actions/create-remove-token-for-org"

Create a remove token for an organization.

  POST /orgs/{org}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
func (c *Client) ActionsCreateRemoveTokenForOrg(ctx context.Context, req *ActionsCreateRemoveTokenForOrgReq, opt ...RequestOption) (*ActionsCreateRemoveTokenForOrgResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsCreateRemoveTokenForOrgResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsCreateRemoveTokenForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRemoveTokenForOrgReq is request data for Client.ActionsCreateRemoveTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
type ActionsCreateRemoveTokenForOrgReq struct {
	pgURL string
	Org   string
}

func (r *ActionsCreateRemoveTokenForOrgReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsCreateRemoveTokenForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners/remove-token", r.Org)
}

func (r *ActionsCreateRemoveTokenForOrgReq) method() string {
	return "POST"
}

func (r *ActionsCreateRemoveTokenForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateRemoveTokenForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateRemoveTokenForOrgReq) body() interface{} {
	return nil
}

func (r *ActionsCreateRemoveTokenForOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRemoveTokenForOrgReq) validStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRemoveTokenForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsCreateRemoveTokenForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRemoveTokenForOrgReq) Rel(link RelName, resp *ActionsCreateRemoveTokenForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsCreateRemoveTokenForOrgResponseBody is a response body for ActionsCreateRemoveTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
type ActionsCreateRemoveTokenForOrgResponseBody struct {
	components.AuthenticationToken
}

/*
ActionsCreateRemoveTokenForOrgResponse is a response for ActionsCreateRemoveTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
type ActionsCreateRemoveTokenForOrgResponse struct {
	response
	request *ActionsCreateRemoveTokenForOrgReq
	Data    *ActionsCreateRemoveTokenForOrgResponseBody
}

/*
ActionsCreateRemoveTokenForRepo performs requests for "actions/create-remove-token-for-repo"

Create a remove token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
func (c *Client) ActionsCreateRemoveTokenForRepo(ctx context.Context, req *ActionsCreateRemoveTokenForRepoReq, opt ...RequestOption) (*ActionsCreateRemoveTokenForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsCreateRemoveTokenForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsCreateRemoveTokenForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRemoveTokenForRepoReq is request data for Client.ActionsCreateRemoveTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
type ActionsCreateRemoveTokenForRepoReq struct {
	pgURL string
	Owner string
	Repo  string
}

func (r *ActionsCreateRemoveTokenForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsCreateRemoveTokenForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners/remove-token", r.Owner, r.Repo)
}

func (r *ActionsCreateRemoveTokenForRepoReq) method() string {
	return "POST"
}

func (r *ActionsCreateRemoveTokenForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateRemoveTokenForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateRemoveTokenForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsCreateRemoveTokenForRepoReq) dataStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRemoveTokenForRepoReq) validStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRemoveTokenForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsCreateRemoveTokenForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRemoveTokenForRepoReq) Rel(link RelName, resp *ActionsCreateRemoveTokenForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsCreateRemoveTokenForRepoResponseBody is a response body for ActionsCreateRemoveTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
type ActionsCreateRemoveTokenForRepoResponseBody struct {
	components.AuthenticationToken
}

/*
ActionsCreateRemoveTokenForRepoResponse is a response for ActionsCreateRemoveTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
type ActionsCreateRemoveTokenForRepoResponse struct {
	response
	request *ActionsCreateRemoveTokenForRepoReq
	Data    *ActionsCreateRemoveTokenForRepoResponseBody
}

/*
ActionsDeleteArtifact performs requests for "actions/delete-artifact"

Delete an artifact.

  DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
func (c *Client) ActionsDeleteArtifact(ctx context.Context, req *ActionsDeleteArtifactReq, opt ...RequestOption) (*ActionsDeleteArtifactResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsDeleteArtifactResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteArtifactReq is request data for Client.ActionsDeleteArtifact

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
type ActionsDeleteArtifactReq struct {
	pgURL      string
	Owner      string
	Repo       string
	ArtifactId int64
}

func (r *ActionsDeleteArtifactReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsDeleteArtifactReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v", r.Owner, r.Repo, r.ArtifactId)
}

func (r *ActionsDeleteArtifactReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteArtifactReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteArtifactReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteArtifactReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteArtifactReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteArtifactReq) validStatuses() []int {
	return []int{204}
}

func (r *ActionsDeleteArtifactReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsDeleteArtifactReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteArtifactReq) Rel(link RelName, resp *ActionsDeleteArtifactResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsDeleteArtifactResponse is a response for ActionsDeleteArtifact

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
type ActionsDeleteArtifactResponse struct {
	response
	request *ActionsDeleteArtifactReq
}

/*
ActionsDeleteOrgSecret performs requests for "actions/delete-org-secret"

Delete an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
func (c *Client) ActionsDeleteOrgSecret(ctx context.Context, req *ActionsDeleteOrgSecretReq, opt ...RequestOption) (*ActionsDeleteOrgSecretResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsDeleteOrgSecretResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteOrgSecretReq is request data for Client.ActionsDeleteOrgSecret

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
type ActionsDeleteOrgSecretReq struct {
	pgURL      string
	Org        string
	SecretName string
}

func (r *ActionsDeleteOrgSecretReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsDeleteOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName)
}

func (r *ActionsDeleteOrgSecretReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteOrgSecretReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteOrgSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteOrgSecretReq) validStatuses() []int {
	return []int{204}
}

func (r *ActionsDeleteOrgSecretReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsDeleteOrgSecretReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteOrgSecretReq) Rel(link RelName, resp *ActionsDeleteOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsDeleteOrgSecretResponse is a response for ActionsDeleteOrgSecret

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
type ActionsDeleteOrgSecretResponse struct {
	response
	request *ActionsDeleteOrgSecretReq
}

/*
ActionsDeleteRepoSecret performs requests for "actions/delete-repo-secret"

Delete a repository secret.

  DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
func (c *Client) ActionsDeleteRepoSecret(ctx context.Context, req *ActionsDeleteRepoSecretReq, opt ...RequestOption) (*ActionsDeleteRepoSecretResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsDeleteRepoSecretResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteRepoSecretReq is request data for Client.ActionsDeleteRepoSecret

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
type ActionsDeleteRepoSecretReq struct {
	pgURL      string
	Owner      string
	Repo       string
	SecretName string
}

func (r *ActionsDeleteRepoSecretReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsDeleteRepoSecretReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName)
}

func (r *ActionsDeleteRepoSecretReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteRepoSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteRepoSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteRepoSecretReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteRepoSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteRepoSecretReq) validStatuses() []int {
	return []int{204}
}

func (r *ActionsDeleteRepoSecretReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsDeleteRepoSecretReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteRepoSecretReq) Rel(link RelName, resp *ActionsDeleteRepoSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsDeleteRepoSecretResponse is a response for ActionsDeleteRepoSecret

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
type ActionsDeleteRepoSecretResponse struct {
	response
	request *ActionsDeleteRepoSecretReq
}

/*
ActionsDeleteSelfHostedRunnerFromOrg performs requests for "actions/delete-self-hosted-runner-from-org"

Delete a self-hosted runner from an organization.

  DELETE /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
func (c *Client) ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, req *ActionsDeleteSelfHostedRunnerFromOrgReq, opt ...RequestOption) (*ActionsDeleteSelfHostedRunnerFromOrgResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsDeleteSelfHostedRunnerFromOrgResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteSelfHostedRunnerFromOrgReq is request data for Client.ActionsDeleteSelfHostedRunnerFromOrg

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
type ActionsDeleteSelfHostedRunnerFromOrgReq struct {
	pgURL    string
	Org      string
	RunnerId int64
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners/%v", r.Org, r.RunnerId)
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) validStatuses() []int {
	return []int{204}
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) Rel(link RelName, resp *ActionsDeleteSelfHostedRunnerFromOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsDeleteSelfHostedRunnerFromOrgResponse is a response for ActionsDeleteSelfHostedRunnerFromOrg

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
type ActionsDeleteSelfHostedRunnerFromOrgResponse struct {
	response
	request *ActionsDeleteSelfHostedRunnerFromOrgReq
}

/*
ActionsDeleteSelfHostedRunnerFromRepo performs requests for "actions/delete-self-hosted-runner-from-repo"

Delete a self-hosted runner from a repository.

  DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
func (c *Client) ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, req *ActionsDeleteSelfHostedRunnerFromRepoReq, opt ...RequestOption) (*ActionsDeleteSelfHostedRunnerFromRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsDeleteSelfHostedRunnerFromRepoResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteSelfHostedRunnerFromRepoReq is request data for Client.ActionsDeleteSelfHostedRunnerFromRepo

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
type ActionsDeleteSelfHostedRunnerFromRepoReq struct {
	pgURL    string
	Owner    string
	Repo     string
	RunnerId int64
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners/%v", r.Owner, r.Repo, r.RunnerId)
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) validStatuses() []int {
	return []int{204}
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) Rel(link RelName, resp *ActionsDeleteSelfHostedRunnerFromRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsDeleteSelfHostedRunnerFromRepoResponse is a response for ActionsDeleteSelfHostedRunnerFromRepo

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
type ActionsDeleteSelfHostedRunnerFromRepoResponse struct {
	response
	request *ActionsDeleteSelfHostedRunnerFromRepoReq
}

/*
ActionsDeleteWorkflowRunLogs performs requests for "actions/delete-workflow-run-logs"

Delete workflow run logs.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
func (c *Client) ActionsDeleteWorkflowRunLogs(ctx context.Context, req *ActionsDeleteWorkflowRunLogsReq, opt ...RequestOption) (*ActionsDeleteWorkflowRunLogsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsDeleteWorkflowRunLogsResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteWorkflowRunLogsReq is request data for Client.ActionsDeleteWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
type ActionsDeleteWorkflowRunLogsReq struct {
	pgURL string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsDeleteWorkflowRunLogsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsDeleteWorkflowRunLogsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/logs", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsDeleteWorkflowRunLogsReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteWorkflowRunLogsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteWorkflowRunLogsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteWorkflowRunLogsReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteWorkflowRunLogsReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteWorkflowRunLogsReq) validStatuses() []int {
	return []int{204}
}

func (r *ActionsDeleteWorkflowRunLogsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsDeleteWorkflowRunLogsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteWorkflowRunLogsReq) Rel(link RelName, resp *ActionsDeleteWorkflowRunLogsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsDeleteWorkflowRunLogsResponse is a response for ActionsDeleteWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
type ActionsDeleteWorkflowRunLogsResponse struct {
	response
	request *ActionsDeleteWorkflowRunLogsReq
}

/*
ActionsDownloadArtifact performs requests for "actions/download-artifact"

Download an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
func (c *Client) ActionsDownloadArtifact(ctx context.Context, req *ActionsDownloadArtifactReq, opt ...RequestOption) (*ActionsDownloadArtifactResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsDownloadArtifactResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDownloadArtifactReq is request data for Client.ActionsDownloadArtifact

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
type ActionsDownloadArtifactReq struct {
	pgURL         string
	Owner         string
	Repo          string
	ArtifactId    int64
	ArchiveFormat string
}

func (r *ActionsDownloadArtifactReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsDownloadArtifactReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v/%v", r.Owner, r.Repo, r.ArtifactId, r.ArchiveFormat)
}

func (r *ActionsDownloadArtifactReq) method() string {
	return "GET"
}

func (r *ActionsDownloadArtifactReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDownloadArtifactReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDownloadArtifactReq) body() interface{} {
	return nil
}

func (r *ActionsDownloadArtifactReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDownloadArtifactReq) validStatuses() []int {
	return []int{302}
}

func (r *ActionsDownloadArtifactReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrRedirect}
}

// httpRequest creates an http request
func (r *ActionsDownloadArtifactReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDownloadArtifactReq) Rel(link RelName, resp *ActionsDownloadArtifactResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsDownloadArtifactResponse is a response for ActionsDownloadArtifact

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
type ActionsDownloadArtifactResponse struct {
	response
	request *ActionsDownloadArtifactReq
}

/*
ActionsDownloadWorkflowJobLogs performs requests for "actions/download-workflow-job-logs"

Download workflow job logs.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs

https://developer.github.com/v3/actions/workflow-jobs/#download-workflow-job-logs
*/
func (c *Client) ActionsDownloadWorkflowJobLogs(ctx context.Context, req *ActionsDownloadWorkflowJobLogsReq, opt ...RequestOption) (*ActionsDownloadWorkflowJobLogsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsDownloadWorkflowJobLogsResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDownloadWorkflowJobLogsReq is request data for Client.ActionsDownloadWorkflowJobLogs

https://developer.github.com/v3/actions/workflow-jobs/#download-workflow-job-logs
*/
type ActionsDownloadWorkflowJobLogsReq struct {
	pgURL string
	Owner string
	Repo  string
	JobId int64
}

func (r *ActionsDownloadWorkflowJobLogsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsDownloadWorkflowJobLogsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/jobs/%v/logs", r.Owner, r.Repo, r.JobId)
}

func (r *ActionsDownloadWorkflowJobLogsReq) method() string {
	return "GET"
}

func (r *ActionsDownloadWorkflowJobLogsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDownloadWorkflowJobLogsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDownloadWorkflowJobLogsReq) body() interface{} {
	return nil
}

func (r *ActionsDownloadWorkflowJobLogsReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDownloadWorkflowJobLogsReq) validStatuses() []int {
	return []int{302}
}

func (r *ActionsDownloadWorkflowJobLogsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrRedirect}
}

// httpRequest creates an http request
func (r *ActionsDownloadWorkflowJobLogsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDownloadWorkflowJobLogsReq) Rel(link RelName, resp *ActionsDownloadWorkflowJobLogsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsDownloadWorkflowJobLogsResponse is a response for ActionsDownloadWorkflowJobLogs

https://developer.github.com/v3/actions/workflow-jobs/#download-workflow-job-logs
*/
type ActionsDownloadWorkflowJobLogsResponse struct {
	response
	request *ActionsDownloadWorkflowJobLogsReq
}

/*
ActionsDownloadWorkflowRunLogs performs requests for "actions/download-workflow-run-logs"

Download workflow run logs.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
func (c *Client) ActionsDownloadWorkflowRunLogs(ctx context.Context, req *ActionsDownloadWorkflowRunLogsReq, opt ...RequestOption) (*ActionsDownloadWorkflowRunLogsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsDownloadWorkflowRunLogsResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDownloadWorkflowRunLogsReq is request data for Client.ActionsDownloadWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
type ActionsDownloadWorkflowRunLogsReq struct {
	pgURL string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsDownloadWorkflowRunLogsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsDownloadWorkflowRunLogsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/logs", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsDownloadWorkflowRunLogsReq) method() string {
	return "GET"
}

func (r *ActionsDownloadWorkflowRunLogsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDownloadWorkflowRunLogsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDownloadWorkflowRunLogsReq) body() interface{} {
	return nil
}

func (r *ActionsDownloadWorkflowRunLogsReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDownloadWorkflowRunLogsReq) validStatuses() []int {
	return []int{302}
}

func (r *ActionsDownloadWorkflowRunLogsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{attrRedirect}
}

// httpRequest creates an http request
func (r *ActionsDownloadWorkflowRunLogsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDownloadWorkflowRunLogsReq) Rel(link RelName, resp *ActionsDownloadWorkflowRunLogsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsDownloadWorkflowRunLogsResponse is a response for ActionsDownloadWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
type ActionsDownloadWorkflowRunLogsResponse struct {
	response
	request *ActionsDownloadWorkflowRunLogsReq
}

/*
ActionsGetArtifact performs requests for "actions/get-artifact"

Get an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
func (c *Client) ActionsGetArtifact(ctx context.Context, req *ActionsGetArtifactReq, opt ...RequestOption) (*ActionsGetArtifactResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetArtifactResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetArtifactResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetArtifactReq is request data for Client.ActionsGetArtifact

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
type ActionsGetArtifactReq struct {
	pgURL      string
	Owner      string
	Repo       string
	ArtifactId int64
}

func (r *ActionsGetArtifactReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetArtifactReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v", r.Owner, r.Repo, r.ArtifactId)
}

func (r *ActionsGetArtifactReq) method() string {
	return "GET"
}

func (r *ActionsGetArtifactReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetArtifactReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetArtifactReq) body() interface{} {
	return nil
}

func (r *ActionsGetArtifactReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetArtifactReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsGetArtifactReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetArtifactReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetArtifactReq) Rel(link RelName, resp *ActionsGetArtifactResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetArtifactResponseBody is a response body for ActionsGetArtifact

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
type ActionsGetArtifactResponseBody struct {
	components.Artifact
}

/*
ActionsGetArtifactResponse is a response for ActionsGetArtifact

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
type ActionsGetArtifactResponse struct {
	response
	request *ActionsGetArtifactReq
	Data    *ActionsGetArtifactResponseBody
}

/*
ActionsGetOrgPublicKey performs requests for "actions/get-org-public-key"

Get an organization public key.

  GET /orgs/{org}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
func (c *Client) ActionsGetOrgPublicKey(ctx context.Context, req *ActionsGetOrgPublicKeyReq, opt ...RequestOption) (*ActionsGetOrgPublicKeyResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetOrgPublicKeyResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetOrgPublicKeyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetOrgPublicKeyReq is request data for Client.ActionsGetOrgPublicKey

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
type ActionsGetOrgPublicKeyReq struct {
	pgURL string
	Org   string
}

func (r *ActionsGetOrgPublicKeyReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetOrgPublicKeyReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/public-key", r.Org)
}

func (r *ActionsGetOrgPublicKeyReq) method() string {
	return "GET"
}

func (r *ActionsGetOrgPublicKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetOrgPublicKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetOrgPublicKeyReq) body() interface{} {
	return nil
}

func (r *ActionsGetOrgPublicKeyReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetOrgPublicKeyReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsGetOrgPublicKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetOrgPublicKeyReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetOrgPublicKeyReq) Rel(link RelName, resp *ActionsGetOrgPublicKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetOrgPublicKeyResponseBody is a response body for ActionsGetOrgPublicKey

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
type ActionsGetOrgPublicKeyResponseBody struct {
	components.ActionsPublicKey
}

/*
ActionsGetOrgPublicKeyResponse is a response for ActionsGetOrgPublicKey

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
type ActionsGetOrgPublicKeyResponse struct {
	response
	request *ActionsGetOrgPublicKeyReq
	Data    *ActionsGetOrgPublicKeyResponseBody
}

/*
ActionsGetOrgSecret performs requests for "actions/get-org-secret"

Get an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
func (c *Client) ActionsGetOrgSecret(ctx context.Context, req *ActionsGetOrgSecretReq, opt ...RequestOption) (*ActionsGetOrgSecretResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetOrgSecretResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetOrgSecretResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetOrgSecretReq is request data for Client.ActionsGetOrgSecret

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
type ActionsGetOrgSecretReq struct {
	pgURL      string
	Org        string
	SecretName string
}

func (r *ActionsGetOrgSecretReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName)
}

func (r *ActionsGetOrgSecretReq) method() string {
	return "GET"
}

func (r *ActionsGetOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetOrgSecretReq) body() interface{} {
	return nil
}

func (r *ActionsGetOrgSecretReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetOrgSecretReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsGetOrgSecretReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetOrgSecretReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetOrgSecretReq) Rel(link RelName, resp *ActionsGetOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetOrgSecretResponseBody is a response body for ActionsGetOrgSecret

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
type ActionsGetOrgSecretResponseBody struct {
	components.OrganizationActionsSecret
}

/*
ActionsGetOrgSecretResponse is a response for ActionsGetOrgSecret

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
type ActionsGetOrgSecretResponse struct {
	response
	request *ActionsGetOrgSecretReq
	Data    *ActionsGetOrgSecretResponseBody
}

/*
ActionsGetRepoPublicKey performs requests for "actions/get-repo-public-key"

Get a repository public key.

  GET /repos/{owner}/{repo}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
func (c *Client) ActionsGetRepoPublicKey(ctx context.Context, req *ActionsGetRepoPublicKeyReq, opt ...RequestOption) (*ActionsGetRepoPublicKeyResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetRepoPublicKeyResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetRepoPublicKeyResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetRepoPublicKeyReq is request data for Client.ActionsGetRepoPublicKey

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
type ActionsGetRepoPublicKeyReq struct {
	pgURL string
	Owner string
	Repo  string
}

func (r *ActionsGetRepoPublicKeyReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetRepoPublicKeyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/secrets/public-key", r.Owner, r.Repo)
}

func (r *ActionsGetRepoPublicKeyReq) method() string {
	return "GET"
}

func (r *ActionsGetRepoPublicKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetRepoPublicKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetRepoPublicKeyReq) body() interface{} {
	return nil
}

func (r *ActionsGetRepoPublicKeyReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetRepoPublicKeyReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsGetRepoPublicKeyReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetRepoPublicKeyReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetRepoPublicKeyReq) Rel(link RelName, resp *ActionsGetRepoPublicKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetRepoPublicKeyResponseBody is a response body for ActionsGetRepoPublicKey

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
type ActionsGetRepoPublicKeyResponseBody struct {
	components.ActionsPublicKey
}

/*
ActionsGetRepoPublicKeyResponse is a response for ActionsGetRepoPublicKey

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
type ActionsGetRepoPublicKeyResponse struct {
	response
	request *ActionsGetRepoPublicKeyReq
	Data    *ActionsGetRepoPublicKeyResponseBody
}

/*
ActionsGetRepoSecret performs requests for "actions/get-repo-secret"

Get a repository secret.

  GET /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
func (c *Client) ActionsGetRepoSecret(ctx context.Context, req *ActionsGetRepoSecretReq, opt ...RequestOption) (*ActionsGetRepoSecretResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetRepoSecretResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetRepoSecretResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetRepoSecretReq is request data for Client.ActionsGetRepoSecret

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
type ActionsGetRepoSecretReq struct {
	pgURL      string
	Owner      string
	Repo       string
	SecretName string
}

func (r *ActionsGetRepoSecretReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetRepoSecretReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName)
}

func (r *ActionsGetRepoSecretReq) method() string {
	return "GET"
}

func (r *ActionsGetRepoSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetRepoSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetRepoSecretReq) body() interface{} {
	return nil
}

func (r *ActionsGetRepoSecretReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetRepoSecretReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsGetRepoSecretReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetRepoSecretReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetRepoSecretReq) Rel(link RelName, resp *ActionsGetRepoSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetRepoSecretResponseBody is a response body for ActionsGetRepoSecret

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
type ActionsGetRepoSecretResponseBody struct {
	components.ActionsSecret
}

/*
ActionsGetRepoSecretResponse is a response for ActionsGetRepoSecret

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
type ActionsGetRepoSecretResponse struct {
	response
	request *ActionsGetRepoSecretReq
	Data    *ActionsGetRepoSecretResponseBody
}

/*
ActionsGetSelfHostedRunnerForOrg performs requests for "actions/get-self-hosted-runner-for-org"

Get a self-hosted runner for an organization.

  GET /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
func (c *Client) ActionsGetSelfHostedRunnerForOrg(ctx context.Context, req *ActionsGetSelfHostedRunnerForOrgReq, opt ...RequestOption) (*ActionsGetSelfHostedRunnerForOrgResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetSelfHostedRunnerForOrgResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetSelfHostedRunnerForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetSelfHostedRunnerForOrgReq is request data for Client.ActionsGetSelfHostedRunnerForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
type ActionsGetSelfHostedRunnerForOrgReq struct {
	pgURL    string
	Org      string
	RunnerId int64
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners/%v", r.Org, r.RunnerId)
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) method() string {
	return "GET"
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) body() interface{} {
	return nil
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetSelfHostedRunnerForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetSelfHostedRunnerForOrgReq) Rel(link RelName, resp *ActionsGetSelfHostedRunnerForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetSelfHostedRunnerForOrgResponseBody is a response body for ActionsGetSelfHostedRunnerForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
type ActionsGetSelfHostedRunnerForOrgResponseBody struct {
	components.Runner
}

/*
ActionsGetSelfHostedRunnerForOrgResponse is a response for ActionsGetSelfHostedRunnerForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
type ActionsGetSelfHostedRunnerForOrgResponse struct {
	response
	request *ActionsGetSelfHostedRunnerForOrgReq
	Data    *ActionsGetSelfHostedRunnerForOrgResponseBody
}

/*
ActionsGetSelfHostedRunnerForRepo performs requests for "actions/get-self-hosted-runner-for-repo"

Get a self-hosted runner for a repository.

  GET /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
func (c *Client) ActionsGetSelfHostedRunnerForRepo(ctx context.Context, req *ActionsGetSelfHostedRunnerForRepoReq, opt ...RequestOption) (*ActionsGetSelfHostedRunnerForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetSelfHostedRunnerForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetSelfHostedRunnerForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetSelfHostedRunnerForRepoReq is request data for Client.ActionsGetSelfHostedRunnerForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
type ActionsGetSelfHostedRunnerForRepoReq struct {
	pgURL    string
	Owner    string
	Repo     string
	RunnerId int64
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners/%v", r.Owner, r.Repo, r.RunnerId)
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) method() string {
	return "GET"
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetSelfHostedRunnerForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetSelfHostedRunnerForRepoReq) Rel(link RelName, resp *ActionsGetSelfHostedRunnerForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetSelfHostedRunnerForRepoResponseBody is a response body for ActionsGetSelfHostedRunnerForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
type ActionsGetSelfHostedRunnerForRepoResponseBody struct {
	components.Runner
}

/*
ActionsGetSelfHostedRunnerForRepoResponse is a response for ActionsGetSelfHostedRunnerForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
type ActionsGetSelfHostedRunnerForRepoResponse struct {
	response
	request *ActionsGetSelfHostedRunnerForRepoReq
	Data    *ActionsGetSelfHostedRunnerForRepoResponseBody
}

/*
ActionsGetWorkflow performs requests for "actions/get-workflow"

Get a workflow.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
func (c *Client) ActionsGetWorkflow(ctx context.Context, req *ActionsGetWorkflowReq, opt ...RequestOption) (*ActionsGetWorkflowResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetWorkflowResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetWorkflowResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflowReq is request data for Client.ActionsGetWorkflow

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
type ActionsGetWorkflowReq struct {
	pgURL      string
	Owner      string
	Repo       string
	WorkflowId int64
}

func (r *ActionsGetWorkflowReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetWorkflowReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/workflows/%v", r.Owner, r.Repo, r.WorkflowId)
}

func (r *ActionsGetWorkflowReq) method() string {
	return "GET"
}

func (r *ActionsGetWorkflowReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetWorkflowReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetWorkflowReq) body() interface{} {
	return nil
}

func (r *ActionsGetWorkflowReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetWorkflowReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowReq) Rel(link RelName, resp *ActionsGetWorkflowResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetWorkflowResponseBody is a response body for ActionsGetWorkflow

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
type ActionsGetWorkflowResponseBody struct {
	components.Workflow
}

/*
ActionsGetWorkflowResponse is a response for ActionsGetWorkflow

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
type ActionsGetWorkflowResponse struct {
	response
	request *ActionsGetWorkflowReq
	Data    *ActionsGetWorkflowResponseBody
}

/*
ActionsGetWorkflowJob performs requests for "actions/get-workflow-job"

Get a workflow job.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}

https://developer.github.com/v3/actions/workflow-jobs/#get-a-workflow-job
*/
func (c *Client) ActionsGetWorkflowJob(ctx context.Context, req *ActionsGetWorkflowJobReq, opt ...RequestOption) (*ActionsGetWorkflowJobResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetWorkflowJobResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetWorkflowJobResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflowJobReq is request data for Client.ActionsGetWorkflowJob

https://developer.github.com/v3/actions/workflow-jobs/#get-a-workflow-job
*/
type ActionsGetWorkflowJobReq struct {
	pgURL string
	Owner string
	Repo  string
	JobId int64
}

func (r *ActionsGetWorkflowJobReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetWorkflowJobReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/jobs/%v", r.Owner, r.Repo, r.JobId)
}

func (r *ActionsGetWorkflowJobReq) method() string {
	return "GET"
}

func (r *ActionsGetWorkflowJobReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetWorkflowJobReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetWorkflowJobReq) body() interface{} {
	return nil
}

func (r *ActionsGetWorkflowJobReq) dataStatuses() []int {
	return []int{202}
}

func (r *ActionsGetWorkflowJobReq) validStatuses() []int {
	return []int{202}
}

func (r *ActionsGetWorkflowJobReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetWorkflowJobReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowJobReq) Rel(link RelName, resp *ActionsGetWorkflowJobResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetWorkflowJobResponseBody is a response body for ActionsGetWorkflowJob

https://developer.github.com/v3/actions/workflow-jobs/#get-a-workflow-job
*/
type ActionsGetWorkflowJobResponseBody struct {
	components.Job
}

/*
ActionsGetWorkflowJobResponse is a response for ActionsGetWorkflowJob

https://developer.github.com/v3/actions/workflow-jobs/#get-a-workflow-job
*/
type ActionsGetWorkflowJobResponse struct {
	response
	request *ActionsGetWorkflowJobReq
	Data    *ActionsGetWorkflowJobResponseBody
}

/*
ActionsGetWorkflowRun performs requests for "actions/get-workflow-run"

Get a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
func (c *Client) ActionsGetWorkflowRun(ctx context.Context, req *ActionsGetWorkflowRunReq, opt ...RequestOption) (*ActionsGetWorkflowRunResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetWorkflowRunResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetWorkflowRunResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflowRunReq is request data for Client.ActionsGetWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
type ActionsGetWorkflowRunReq struct {
	pgURL string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsGetWorkflowRunReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetWorkflowRunReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsGetWorkflowRunReq) method() string {
	return "GET"
}

func (r *ActionsGetWorkflowRunReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetWorkflowRunReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetWorkflowRunReq) body() interface{} {
	return nil
}

func (r *ActionsGetWorkflowRunReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowRunReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowRunReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetWorkflowRunReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowRunReq) Rel(link RelName, resp *ActionsGetWorkflowRunResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetWorkflowRunResponseBody is a response body for ActionsGetWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
type ActionsGetWorkflowRunResponseBody struct {
	components.WorkflowRun
}

/*
ActionsGetWorkflowRunResponse is a response for ActionsGetWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
type ActionsGetWorkflowRunResponse struct {
	response
	request *ActionsGetWorkflowRunReq
	Data    *ActionsGetWorkflowRunResponseBody
}

/*
ActionsGetWorkflowRunUsage performs requests for "actions/get-workflow-run-usage"

Get workflow run usage.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
func (c *Client) ActionsGetWorkflowRunUsage(ctx context.Context, req *ActionsGetWorkflowRunUsageReq, opt ...RequestOption) (*ActionsGetWorkflowRunUsageResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetWorkflowRunUsageResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetWorkflowRunUsageResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflowRunUsageReq is request data for Client.ActionsGetWorkflowRunUsage

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
type ActionsGetWorkflowRunUsageReq struct {
	pgURL string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsGetWorkflowRunUsageReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetWorkflowRunUsageReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/timing", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsGetWorkflowRunUsageReq) method() string {
	return "GET"
}

func (r *ActionsGetWorkflowRunUsageReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetWorkflowRunUsageReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetWorkflowRunUsageReq) body() interface{} {
	return nil
}

func (r *ActionsGetWorkflowRunUsageReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowRunUsageReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowRunUsageReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetWorkflowRunUsageReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowRunUsageReq) Rel(link RelName, resp *ActionsGetWorkflowRunUsageResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetWorkflowRunUsageResponseBody is a response body for ActionsGetWorkflowRunUsage

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
type ActionsGetWorkflowRunUsageResponseBody struct {
	components.WorkfloRunUsage
}

/*
ActionsGetWorkflowRunUsageResponse is a response for ActionsGetWorkflowRunUsage

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
type ActionsGetWorkflowRunUsageResponse struct {
	response
	request *ActionsGetWorkflowRunUsageReq
	Data    *ActionsGetWorkflowRunUsageResponseBody
}

/*
ActionsGetWorkflowUsage performs requests for "actions/get-workflow-usage"

Get workflow usage.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
func (c *Client) ActionsGetWorkflowUsage(ctx context.Context, req *ActionsGetWorkflowUsageReq, opt ...RequestOption) (*ActionsGetWorkflowUsageResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsGetWorkflowUsageResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsGetWorkflowUsageResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflowUsageReq is request data for Client.ActionsGetWorkflowUsage

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
type ActionsGetWorkflowUsageReq struct {
	pgURL      string
	Owner      string
	Repo       string
	WorkflowId int64
}

func (r *ActionsGetWorkflowUsageReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsGetWorkflowUsageReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/workflows/%v/timing", r.Owner, r.Repo, r.WorkflowId)
}

func (r *ActionsGetWorkflowUsageReq) method() string {
	return "GET"
}

func (r *ActionsGetWorkflowUsageReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetWorkflowUsageReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetWorkflowUsageReq) body() interface{} {
	return nil
}

func (r *ActionsGetWorkflowUsageReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowUsageReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowUsageReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsGetWorkflowUsageReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowUsageReq) Rel(link RelName, resp *ActionsGetWorkflowUsageResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsGetWorkflowUsageResponseBody is a response body for ActionsGetWorkflowUsage

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
type ActionsGetWorkflowUsageResponseBody struct {
	components.WorkfloUsage
}

/*
ActionsGetWorkflowUsageResponse is a response for ActionsGetWorkflowUsage

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
type ActionsGetWorkflowUsageResponse struct {
	response
	request *ActionsGetWorkflowUsageReq
	Data    *ActionsGetWorkflowUsageResponseBody
}

/*
ActionsListArtifactsForRepo performs requests for "actions/list-artifacts-for-repo"

List artifacts for a repository.

  GET /repos/{owner}/{repo}/actions/artifacts

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
func (c *Client) ActionsListArtifactsForRepo(ctx context.Context, req *ActionsListArtifactsForRepoReq, opt ...RequestOption) (*ActionsListArtifactsForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListArtifactsForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListArtifactsForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListArtifactsForRepoReq is request data for Client.ActionsListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ActionsListArtifactsForRepoReq struct {
	pgURL string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListArtifactsForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListArtifactsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/artifacts", r.Owner, r.Repo)
}

func (r *ActionsListArtifactsForRepoReq) method() string {
	return "GET"
}

func (r *ActionsListArtifactsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListArtifactsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListArtifactsForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsListArtifactsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListArtifactsForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListArtifactsForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListArtifactsForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListArtifactsForRepoReq) Rel(link RelName, resp *ActionsListArtifactsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListArtifactsForRepoResponseBody is a response body for ActionsListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ActionsListArtifactsForRepoResponseBody struct {
	Artifacts []struct {
		components.Artifact2
	} `json:"artifacts,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
ActionsListArtifactsForRepoResponse is a response for ActionsListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ActionsListArtifactsForRepoResponse struct {
	response
	request *ActionsListArtifactsForRepoReq
	Data    *ActionsListArtifactsForRepoResponseBody
}

/*
ActionsListJobsForWorkflowRun performs requests for "actions/list-jobs-for-workflow-run"

List jobs for a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
func (c *Client) ActionsListJobsForWorkflowRun(ctx context.Context, req *ActionsListJobsForWorkflowRunReq, opt ...RequestOption) (*ActionsListJobsForWorkflowRunResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListJobsForWorkflowRunResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListJobsForWorkflowRunResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListJobsForWorkflowRunReq is request data for Client.ActionsListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ActionsListJobsForWorkflowRunReq struct {
	pgURL string
	Owner string
	Repo  string
	RunId int64

	/*
	Filters jobs by their `completed_at` timestamp. Can be one of:
	\* `latest`: Returns jobs from the most recent execution of the workflow run.
	\* `all`: Returns all jobs for a workflow run, including from old executions of
	the workflow run.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListJobsForWorkflowRunReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListJobsForWorkflowRunReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/jobs", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsListJobsForWorkflowRunReq) method() string {
	return "GET"
}

func (r *ActionsListJobsForWorkflowRunReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListJobsForWorkflowRunReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListJobsForWorkflowRunReq) body() interface{} {
	return nil
}

func (r *ActionsListJobsForWorkflowRunReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListJobsForWorkflowRunReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListJobsForWorkflowRunReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListJobsForWorkflowRunReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListJobsForWorkflowRunReq) Rel(link RelName, resp *ActionsListJobsForWorkflowRunResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListJobsForWorkflowRunResponseBody is a response body for ActionsListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ActionsListJobsForWorkflowRunResponseBody struct {
	Jobs []struct {
		components.Job
	} `json:"jobs,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
ActionsListJobsForWorkflowRunResponse is a response for ActionsListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ActionsListJobsForWorkflowRunResponse struct {
	response
	request *ActionsListJobsForWorkflowRunReq
	Data    *ActionsListJobsForWorkflowRunResponseBody
}

/*
ActionsListOrgSecrets performs requests for "actions/list-org-secrets"

List organization secrets.

  GET /orgs/{org}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
func (c *Client) ActionsListOrgSecrets(ctx context.Context, req *ActionsListOrgSecretsReq, opt ...RequestOption) (*ActionsListOrgSecretsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListOrgSecretsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListOrgSecretsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListOrgSecretsReq is request data for Client.ActionsListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ActionsListOrgSecretsReq struct {
	pgURL string
	Org   string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListOrgSecretsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListOrgSecretsReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets", r.Org)
}

func (r *ActionsListOrgSecretsReq) method() string {
	return "GET"
}

func (r *ActionsListOrgSecretsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListOrgSecretsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListOrgSecretsReq) body() interface{} {
	return nil
}

func (r *ActionsListOrgSecretsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListOrgSecretsReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListOrgSecretsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListOrgSecretsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListOrgSecretsReq) Rel(link RelName, resp *ActionsListOrgSecretsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListOrgSecretsResponseBody is a response body for ActionsListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ActionsListOrgSecretsResponseBody struct {
	Secrets []struct {
		components.OrganizationActionsSecret2
	} `json:"secrets,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
ActionsListOrgSecretsResponse is a response for ActionsListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ActionsListOrgSecretsResponse struct {
	response
	request *ActionsListOrgSecretsReq
	Data    *ActionsListOrgSecretsResponseBody
}

/*
ActionsListRepoSecrets performs requests for "actions/list-repo-secrets"

List repository secrets.

  GET /repos/{owner}/{repo}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
func (c *Client) ActionsListRepoSecrets(ctx context.Context, req *ActionsListRepoSecretsReq, opt ...RequestOption) (*ActionsListRepoSecretsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListRepoSecretsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListRepoSecretsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRepoSecretsReq is request data for Client.ActionsListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ActionsListRepoSecretsReq struct {
	pgURL string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListRepoSecretsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListRepoSecretsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/secrets", r.Owner, r.Repo)
}

func (r *ActionsListRepoSecretsReq) method() string {
	return "GET"
}

func (r *ActionsListRepoSecretsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListRepoSecretsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListRepoSecretsReq) body() interface{} {
	return nil
}

func (r *ActionsListRepoSecretsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListRepoSecretsReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListRepoSecretsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListRepoSecretsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRepoSecretsReq) Rel(link RelName, resp *ActionsListRepoSecretsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListRepoSecretsResponseBody is a response body for ActionsListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ActionsListRepoSecretsResponseBody struct {
	Secrets []struct {
		components.ActionsSecret2
	} `json:"secrets,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
ActionsListRepoSecretsResponse is a response for ActionsListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ActionsListRepoSecretsResponse struct {
	response
	request *ActionsListRepoSecretsReq
	Data    *ActionsListRepoSecretsResponseBody
}

/*
ActionsListRepoWorkflowRuns performs requests for "actions/list-repo-workflow-runs"

List repository workflow runs.

  GET /repos/{owner}/{repo}/actions/runs

https://developer.github.com/v3/actions/workflow-runs/#list-repository-workflow-runs
*/
func (c *Client) ActionsListRepoWorkflowRuns(ctx context.Context, req *ActionsListRepoWorkflowRunsReq, opt ...RequestOption) (*ActionsListRepoWorkflowRunsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListRepoWorkflowRunsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListRepoWorkflowRunsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRepoWorkflowRunsReq is request data for Client.ActionsListRepoWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-repository-workflow-runs
*/
type ActionsListRepoWorkflowRunsReq struct {
	pgURL string
	Owner string
	Repo  string

	/*
	Returns someone's workflow runs. Use the login for the user who created the
	`push` associated with the check suite or workflow run.
	*/
	Actor *string

	/*
	Returns workflow runs associated with a branch. Use the name of the branch of
	the `push`.
	*/
	Branch *string

	/*
	Returns workflow run triggered by the event you specify. For example, `push`,
	`pull_request` or `issue`. For more information, see "[Events that trigger
	workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)"
	in the GitHub Help documentation.
	*/
	Event *string

	/*
	Returns workflow runs associated with the check run `status` or `conclusion` you
	specify. For example, a conclusion can be `success` or a status can be
	`completed`. For more information, see the `status` and `conclusion` options
	available in "[Create a check
	run](https://developer.github.com/v3/checks/runs/#create-a-check-run)."
	*/
	Status *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListRepoWorkflowRunsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListRepoWorkflowRunsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs", r.Owner, r.Repo)
}

func (r *ActionsListRepoWorkflowRunsReq) method() string {
	return "GET"
}

func (r *ActionsListRepoWorkflowRunsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Actor != nil {
		query.Set("actor", *r.Actor)
	}
	if r.Branch != nil {
		query.Set("branch", *r.Branch)
	}
	if r.Event != nil {
		query.Set("event", *r.Event)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListRepoWorkflowRunsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListRepoWorkflowRunsReq) body() interface{} {
	return nil
}

func (r *ActionsListRepoWorkflowRunsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListRepoWorkflowRunsReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListRepoWorkflowRunsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListRepoWorkflowRunsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRepoWorkflowRunsReq) Rel(link RelName, resp *ActionsListRepoWorkflowRunsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListRepoWorkflowRunsResponseBody is a response body for ActionsListRepoWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-repository-workflow-runs
*/
type ActionsListRepoWorkflowRunsResponseBody struct {
	TotalCount   int64 `json:"total_count,omitempty"`
	WorkflowRuns []struct {
		components.WorkflowRun
	} `json:"workflow_runs,omitempty"`
}

/*
ActionsListRepoWorkflowRunsResponse is a response for ActionsListRepoWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-repository-workflow-runs
*/
type ActionsListRepoWorkflowRunsResponse struct {
	response
	request *ActionsListRepoWorkflowRunsReq
	Data    *ActionsListRepoWorkflowRunsResponseBody
}

/*
ActionsListRepoWorkflows performs requests for "actions/list-repo-workflows"

List repository workflows.

  GET /repos/{owner}/{repo}/actions/workflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
func (c *Client) ActionsListRepoWorkflows(ctx context.Context, req *ActionsListRepoWorkflowsReq, opt ...RequestOption) (*ActionsListRepoWorkflowsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListRepoWorkflowsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListRepoWorkflowsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRepoWorkflowsReq is request data for Client.ActionsListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ActionsListRepoWorkflowsReq struct {
	pgURL string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListRepoWorkflowsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListRepoWorkflowsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/workflows", r.Owner, r.Repo)
}

func (r *ActionsListRepoWorkflowsReq) method() string {
	return "GET"
}

func (r *ActionsListRepoWorkflowsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListRepoWorkflowsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListRepoWorkflowsReq) body() interface{} {
	return nil
}

func (r *ActionsListRepoWorkflowsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListRepoWorkflowsReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListRepoWorkflowsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListRepoWorkflowsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRepoWorkflowsReq) Rel(link RelName, resp *ActionsListRepoWorkflowsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListRepoWorkflowsResponseBody is a response body for ActionsListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ActionsListRepoWorkflowsResponseBody struct {
	TotalCount int64 `json:"total_count,omitempty"`
	Workflows  []struct {
		components.Workflow2
	} `json:"workflows,omitempty"`
}

/*
ActionsListRepoWorkflowsResponse is a response for ActionsListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ActionsListRepoWorkflowsResponse struct {
	response
	request *ActionsListRepoWorkflowsReq
	Data    *ActionsListRepoWorkflowsResponseBody
}

/*
ActionsListRunnerApplicationsForOrg performs requests for "actions/list-runner-applications-for-org"

List runner applications for an organization.

  GET /orgs/{org}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
func (c *Client) ActionsListRunnerApplicationsForOrg(ctx context.Context, req *ActionsListRunnerApplicationsForOrgReq, opt ...RequestOption) (*ActionsListRunnerApplicationsForOrgResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListRunnerApplicationsForOrgResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListRunnerApplicationsForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRunnerApplicationsForOrgReq is request data for Client.ActionsListRunnerApplicationsForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
type ActionsListRunnerApplicationsForOrgReq struct {
	pgURL string
	Org   string
}

func (r *ActionsListRunnerApplicationsForOrgReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListRunnerApplicationsForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners/downloads", r.Org)
}

func (r *ActionsListRunnerApplicationsForOrgReq) method() string {
	return "GET"
}

func (r *ActionsListRunnerApplicationsForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsListRunnerApplicationsForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListRunnerApplicationsForOrgReq) body() interface{} {
	return nil
}

func (r *ActionsListRunnerApplicationsForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListRunnerApplicationsForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListRunnerApplicationsForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListRunnerApplicationsForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRunnerApplicationsForOrgReq) Rel(link RelName, resp *ActionsListRunnerApplicationsForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListRunnerApplicationsForOrgResponseBody is a response body for ActionsListRunnerApplicationsForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
type ActionsListRunnerApplicationsForOrgResponseBody []struct {
	components.RunnerApplication
}

/*
ActionsListRunnerApplicationsForOrgResponse is a response for ActionsListRunnerApplicationsForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
type ActionsListRunnerApplicationsForOrgResponse struct {
	response
	request *ActionsListRunnerApplicationsForOrgReq
	Data    *ActionsListRunnerApplicationsForOrgResponseBody
}

/*
ActionsListRunnerApplicationsForRepo performs requests for "actions/list-runner-applications-for-repo"

List runner applications for a repository.

  GET /repos/{owner}/{repo}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
func (c *Client) ActionsListRunnerApplicationsForRepo(ctx context.Context, req *ActionsListRunnerApplicationsForRepoReq, opt ...RequestOption) (*ActionsListRunnerApplicationsForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListRunnerApplicationsForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListRunnerApplicationsForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRunnerApplicationsForRepoReq is request data for Client.ActionsListRunnerApplicationsForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
type ActionsListRunnerApplicationsForRepoReq struct {
	pgURL string
	Owner string
	Repo  string
}

func (r *ActionsListRunnerApplicationsForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListRunnerApplicationsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners/downloads", r.Owner, r.Repo)
}

func (r *ActionsListRunnerApplicationsForRepoReq) method() string {
	return "GET"
}

func (r *ActionsListRunnerApplicationsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsListRunnerApplicationsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListRunnerApplicationsForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsListRunnerApplicationsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListRunnerApplicationsForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListRunnerApplicationsForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListRunnerApplicationsForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRunnerApplicationsForRepoReq) Rel(link RelName, resp *ActionsListRunnerApplicationsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListRunnerApplicationsForRepoResponseBody is a response body for ActionsListRunnerApplicationsForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
type ActionsListRunnerApplicationsForRepoResponseBody []struct {
	components.RunnerApplication
}

/*
ActionsListRunnerApplicationsForRepoResponse is a response for ActionsListRunnerApplicationsForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
type ActionsListRunnerApplicationsForRepoResponse struct {
	response
	request *ActionsListRunnerApplicationsForRepoReq
	Data    *ActionsListRunnerApplicationsForRepoResponseBody
}

/*
ActionsListSelectedReposForOrgSecret performs requests for "actions/list-selected-repos-for-org-secret"

List selected repositories for an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
func (c *Client) ActionsListSelectedReposForOrgSecret(ctx context.Context, req *ActionsListSelectedReposForOrgSecretReq, opt ...RequestOption) (*ActionsListSelectedReposForOrgSecretResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListSelectedReposForOrgSecretResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListSelectedReposForOrgSecretResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListSelectedReposForOrgSecretReq is request data for Client.ActionsListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ActionsListSelectedReposForOrgSecretReq struct {
	pgURL      string
	Org        string
	SecretName string
}

func (r *ActionsListSelectedReposForOrgSecretReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListSelectedReposForOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories", r.Org, r.SecretName)
}

func (r *ActionsListSelectedReposForOrgSecretReq) method() string {
	return "GET"
}

func (r *ActionsListSelectedReposForOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsListSelectedReposForOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListSelectedReposForOrgSecretReq) body() interface{} {
	return nil
}

func (r *ActionsListSelectedReposForOrgSecretReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListSelectedReposForOrgSecretReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListSelectedReposForOrgSecretReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListSelectedReposForOrgSecretReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListSelectedReposForOrgSecretReq) Rel(link RelName, resp *ActionsListSelectedReposForOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListSelectedReposForOrgSecretResponseBody is a response body for ActionsListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ActionsListSelectedReposForOrgSecretResponseBody struct {
	Repositories []struct {
		components.PublicRepository
	} `json:"repositories,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
ActionsListSelectedReposForOrgSecretResponse is a response for ActionsListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ActionsListSelectedReposForOrgSecretResponse struct {
	response
	request *ActionsListSelectedReposForOrgSecretReq
	Data    *ActionsListSelectedReposForOrgSecretResponseBody
}

/*
ActionsListSelfHostedRunnersForOrg performs requests for "actions/list-self-hosted-runners-for-org"

List self-hosted runners for an organization.

  GET /orgs/{org}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
func (c *Client) ActionsListSelfHostedRunnersForOrg(ctx context.Context, req *ActionsListSelfHostedRunnersForOrgReq, opt ...RequestOption) (*ActionsListSelfHostedRunnersForOrgResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListSelfHostedRunnersForOrgResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListSelfHostedRunnersForOrgResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListSelfHostedRunnersForOrgReq is request data for Client.ActionsListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ActionsListSelfHostedRunnersForOrgReq struct {
	pgURL string
	Org   string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListSelfHostedRunnersForOrgReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListSelfHostedRunnersForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners", r.Org)
}

func (r *ActionsListSelfHostedRunnersForOrgReq) method() string {
	return "GET"
}

func (r *ActionsListSelfHostedRunnersForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListSelfHostedRunnersForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListSelfHostedRunnersForOrgReq) body() interface{} {
	return nil
}

func (r *ActionsListSelfHostedRunnersForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListSelfHostedRunnersForOrgReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListSelfHostedRunnersForOrgReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListSelfHostedRunnersForOrgReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListSelfHostedRunnersForOrgReq) Rel(link RelName, resp *ActionsListSelfHostedRunnersForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListSelfHostedRunnersForOrgResponseBody is a response body for ActionsListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ActionsListSelfHostedRunnersForOrgResponseBody struct {
	Runners []struct {
		components.Runner2
	} `json:"runners,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
ActionsListSelfHostedRunnersForOrgResponse is a response for ActionsListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ActionsListSelfHostedRunnersForOrgResponse struct {
	response
	request *ActionsListSelfHostedRunnersForOrgReq
	Data    *ActionsListSelfHostedRunnersForOrgResponseBody
}

/*
ActionsListSelfHostedRunnersForRepo performs requests for "actions/list-self-hosted-runners-for-repo"

List self-hosted runners for a repository.

  GET /repos/{owner}/{repo}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
func (c *Client) ActionsListSelfHostedRunnersForRepo(ctx context.Context, req *ActionsListSelfHostedRunnersForRepoReq, opt ...RequestOption) (*ActionsListSelfHostedRunnersForRepoResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListSelfHostedRunnersForRepoResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListSelfHostedRunnersForRepoResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListSelfHostedRunnersForRepoReq is request data for Client.ActionsListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ActionsListSelfHostedRunnersForRepoReq struct {
	pgURL string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListSelfHostedRunnersForRepoReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListSelfHostedRunnersForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners", r.Owner, r.Repo)
}

func (r *ActionsListSelfHostedRunnersForRepoReq) method() string {
	return "GET"
}

func (r *ActionsListSelfHostedRunnersForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListSelfHostedRunnersForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListSelfHostedRunnersForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsListSelfHostedRunnersForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListSelfHostedRunnersForRepoReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListSelfHostedRunnersForRepoReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListSelfHostedRunnersForRepoReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListSelfHostedRunnersForRepoReq) Rel(link RelName, resp *ActionsListSelfHostedRunnersForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListSelfHostedRunnersForRepoResponseBody is a response body for ActionsListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ActionsListSelfHostedRunnersForRepoResponseBody struct {
	Runners []struct {
		components.Runner2
	} `json:"runners,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
ActionsListSelfHostedRunnersForRepoResponse is a response for ActionsListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ActionsListSelfHostedRunnersForRepoResponse struct {
	response
	request *ActionsListSelfHostedRunnersForRepoReq
	Data    *ActionsListSelfHostedRunnersForRepoResponseBody
}

/*
ActionsListWorkflowRunArtifacts performs requests for "actions/list-workflow-run-artifacts"

List workflow run artifacts.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
func (c *Client) ActionsListWorkflowRunArtifacts(ctx context.Context, req *ActionsListWorkflowRunArtifactsReq, opt ...RequestOption) (*ActionsListWorkflowRunArtifactsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListWorkflowRunArtifactsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListWorkflowRunArtifactsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListWorkflowRunArtifactsReq is request data for Client.ActionsListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ActionsListWorkflowRunArtifactsReq struct {
	pgURL string
	Owner string
	Repo  string
	RunId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListWorkflowRunArtifactsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListWorkflowRunArtifactsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/artifacts", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsListWorkflowRunArtifactsReq) method() string {
	return "GET"
}

func (r *ActionsListWorkflowRunArtifactsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListWorkflowRunArtifactsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListWorkflowRunArtifactsReq) body() interface{} {
	return nil
}

func (r *ActionsListWorkflowRunArtifactsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListWorkflowRunArtifactsReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListWorkflowRunArtifactsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListWorkflowRunArtifactsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListWorkflowRunArtifactsReq) Rel(link RelName, resp *ActionsListWorkflowRunArtifactsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListWorkflowRunArtifactsResponseBody is a response body for ActionsListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ActionsListWorkflowRunArtifactsResponseBody struct {
	Artifacts []struct {
		components.Artifact2
	} `json:"artifacts,omitempty"`
	TotalCount int64 `json:"total_count,omitempty"`
}

/*
ActionsListWorkflowRunArtifactsResponse is a response for ActionsListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ActionsListWorkflowRunArtifactsResponse struct {
	response
	request *ActionsListWorkflowRunArtifactsReq
	Data    *ActionsListWorkflowRunArtifactsResponseBody
}

/*
ActionsListWorkflowRuns performs requests for "actions/list-workflow-runs"

List workflow runs.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
func (c *Client) ActionsListWorkflowRuns(ctx context.Context, req *ActionsListWorkflowRunsReq, opt ...RequestOption) (*ActionsListWorkflowRunsResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsListWorkflowRunsResponse{
		request:  req,
		response: *r,
	}
	resp.Data = new(ActionsListWorkflowRunsResponseBody)
	err = r.decodeBody(resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListWorkflowRunsReq is request data for Client.ActionsListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ActionsListWorkflowRunsReq struct {
	pgURL      string
	Owner      string
	Repo       string
	WorkflowId int64

	/*
	Returns someone's workflow runs. Use the login for the user who created the
	`push` associated with the check suite or workflow run.
	*/
	Actor *string

	/*
	Returns workflow runs associated with a branch. Use the name of the branch of
	the `push`.
	*/
	Branch *string

	/*
	Returns workflow run triggered by the event you specify. For example, `push`,
	`pull_request` or `issue`. For more information, see "[Events that trigger
	workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)"
	in the GitHub Help documentation.
	*/
	Event *string

	/*
	Returns workflow runs associated with the check run `status` or `conclusion` you
	specify. For example, a conclusion can be `success` or a status can be
	`completed`. For more information, see the `status` and `conclusion` options
	available in "[Create a check
	run](https://developer.github.com/v3/checks/runs/#create-a-check-run)."
	*/
	Status *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListWorkflowRunsReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsListWorkflowRunsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/workflows/%v/runs", r.Owner, r.Repo, r.WorkflowId)
}

func (r *ActionsListWorkflowRunsReq) method() string {
	return "GET"
}

func (r *ActionsListWorkflowRunsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Actor != nil {
		query.Set("actor", *r.Actor)
	}
	if r.Branch != nil {
		query.Set("branch", *r.Branch)
	}
	if r.Event != nil {
		query.Set("event", *r.Event)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListWorkflowRunsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListWorkflowRunsReq) body() interface{} {
	return nil
}

func (r *ActionsListWorkflowRunsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListWorkflowRunsReq) validStatuses() []int {
	return []int{200}
}

func (r *ActionsListWorkflowRunsReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsListWorkflowRunsReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListWorkflowRunsReq) Rel(link RelName, resp *ActionsListWorkflowRunsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsListWorkflowRunsResponseBody is a response body for ActionsListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ActionsListWorkflowRunsResponseBody struct {
	TotalCount   int64 `json:"total_count,omitempty"`
	WorkflowRuns []struct {
		components.WorkflowRun
	} `json:"workflow_runs,omitempty"`
}

/*
ActionsListWorkflowRunsResponse is a response for ActionsListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ActionsListWorkflowRunsResponse struct {
	response
	request *ActionsListWorkflowRunsReq
	Data    *ActionsListWorkflowRunsResponseBody
}

/*
ActionsReRunWorkflow performs requests for "actions/re-run-workflow"

Re-run a workflow.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
func (c *Client) ActionsReRunWorkflow(ctx context.Context, req *ActionsReRunWorkflowReq, opt ...RequestOption) (*ActionsReRunWorkflowResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsReRunWorkflowResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsReRunWorkflowReq is request data for Client.ActionsReRunWorkflow

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
type ActionsReRunWorkflowReq struct {
	pgURL string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsReRunWorkflowReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsReRunWorkflowReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/rerun", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsReRunWorkflowReq) method() string {
	return "POST"
}

func (r *ActionsReRunWorkflowReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsReRunWorkflowReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsReRunWorkflowReq) body() interface{} {
	return nil
}

func (r *ActionsReRunWorkflowReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsReRunWorkflowReq) validStatuses() []int {
	return []int{201}
}

func (r *ActionsReRunWorkflowReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsReRunWorkflowReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsReRunWorkflowReq) Rel(link RelName, resp *ActionsReRunWorkflowResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsReRunWorkflowResponse is a response for ActionsReRunWorkflow

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
type ActionsReRunWorkflowResponse struct {
	response
	request *ActionsReRunWorkflowReq
}

/*
ActionsRemoveSelectedRepoFromOrgSecret performs requests for "actions/remove-selected-repo-from-org-secret"

Remove selected repository from an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
func (c *Client) ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, req *ActionsRemoveSelectedRepoFromOrgSecretReq, opt ...RequestOption) (*ActionsRemoveSelectedRepoFromOrgSecretResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsRemoveSelectedRepoFromOrgSecretResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsRemoveSelectedRepoFromOrgSecretReq is request data for Client.ActionsRemoveSelectedRepoFromOrgSecret

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
type ActionsRemoveSelectedRepoFromOrgSecretReq struct {
	pgURL        string
	Org          string
	SecretName   string
	RepositoryId int64
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories/%v", r.Org, r.SecretName, r.RepositoryId)
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) method() string {
	return "DELETE"
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) body() interface{} {
	return nil
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) validStatuses() []int {
	return []int{204}
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) Rel(link RelName, resp *ActionsRemoveSelectedRepoFromOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsRemoveSelectedRepoFromOrgSecretResponse is a response for ActionsRemoveSelectedRepoFromOrgSecret

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
type ActionsRemoveSelectedRepoFromOrgSecretResponse struct {
	response
	request *ActionsRemoveSelectedRepoFromOrgSecretReq
}

/*
ActionsSetSelectedReposForOrgSecret performs requests for "actions/set-selected-repos-for-org-secret"

Set selected repositories for an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
func (c *Client) ActionsSetSelectedReposForOrgSecret(ctx context.Context, req *ActionsSetSelectedReposForOrgSecretReq, opt ...RequestOption) (*ActionsSetSelectedReposForOrgSecretResponse, error) {
	r, err := c.doRequest(ctx, req, opt...)
	if err != nil {
		return nil, err
	}
	resp := &ActionsSetSelectedReposForOrgSecretResponse{
		request:  req,
		response: *r,
	}
	err = r.decodeBody(nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsSetSelectedReposForOrgSecretReq is request data for Client.ActionsSetSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type ActionsSetSelectedReposForOrgSecretReq struct {
	pgURL       string
	Org         string
	SecretName  string
	RequestBody ActionsSetSelectedReposForOrgSecretReqBody
}

func (r *ActionsSetSelectedReposForOrgSecretReq) pagingURL() string {
	return r.pgURL
}

func (r *ActionsSetSelectedReposForOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories", r.Org, r.SecretName)
}

func (r *ActionsSetSelectedReposForOrgSecretReq) method() string {
	return "PUT"
}

func (r *ActionsSetSelectedReposForOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsSetSelectedReposForOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsSetSelectedReposForOrgSecretReq) body() interface{} {
	return r.RequestBody
}

func (r *ActionsSetSelectedReposForOrgSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsSetSelectedReposForOrgSecretReq) validStatuses() []int {
	return []int{204}
}

func (r *ActionsSetSelectedReposForOrgSecretReq) endpointAttributes() []endpointAttribute {
	return []endpointAttribute{}
}

// httpRequest creates an http request
func (r *ActionsSetSelectedReposForOrgSecretReq) httpRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsSetSelectedReposForOrgSecretReq) Rel(link RelName, resp *ActionsSetSelectedReposForOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r.pgURL = u
	return true
}

/*
ActionsSetSelectedReposForOrgSecretReqBody is a request body for actions/set-selected-repos-for-org-secret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type ActionsSetSelectedReposForOrgSecretReqBody struct {

	/*
	   An array of repository ids that can access the organization secret. You can only
	   provide a list of repository ids when the `visibility` is set to `selected`. You
	   can add and remove individual repositories using the [Set selected repositories
	   for an organization
	   secret](https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret)
	   and [Remove selected repository from an organization
	   secret](https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret)
	   endpoints.
	*/
	SelectedRepositoryIds []int64 `json:"selected_repository_ids,omitempty"`
}

/*
ActionsSetSelectedReposForOrgSecretResponse is a response for ActionsSetSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type ActionsSetSelectedReposForOrgSecretResponse struct {
	response
	request *ActionsSetSelectedReposForOrgSecretReq
}
