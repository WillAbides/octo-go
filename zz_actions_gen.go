// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	common "github.com/willabides/octo-go/common"
	components "github.com/willabides/octo-go/components"
	internal "github.com/willabides/octo-go/internal"
	options "github.com/willabides/octo-go/options"
	"net/http"
	"net/url"
	"strconv"
)

/*
ActionsAddSelectedRepoToOrgSecret performs requests for "actions/add-selected-repo-to-org-secret"

Add selected repository to an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
func ActionsAddSelectedRepoToOrgSecret(ctx context.Context, req *ActionsAddSelectedRepoToOrgSecretReq, opt ...options.Option) (*ActionsAddSelectedRepoToOrgSecretResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsAddSelectedRepoToOrgSecretReq)
	}
	resp := &ActionsAddSelectedRepoToOrgSecretResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsAddSelectedRepoToOrgSecret performs requests for "actions/add-selected-repo-to-org-secret"

Add selected repository to an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
func (c Client) ActionsAddSelectedRepoToOrgSecret(ctx context.Context, req *ActionsAddSelectedRepoToOrgSecretReq, opt ...options.Option) (*ActionsAddSelectedRepoToOrgSecretResponse, error) {
	return ActionsAddSelectedRepoToOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsAddSelectedRepoToOrgSecretReq is request data for Client.ActionsAddSelectedRepoToOrgSecret

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
type ActionsAddSelectedRepoToOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string

	// repository_id parameter
	RepositoryId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsAddSelectedRepoToOrgSecretReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "PUT",
		OperationID:      "actions/add-selected-repo-to-org-secret",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories/%v", r.Org, r.SecretName, r.RepositoryId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsAddSelectedRepoToOrgSecretReq) Rel(link RelName, resp *ActionsAddSelectedRepoToOrgSecretResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsAddSelectedRepoToOrgSecretResponse is a response for ActionsAddSelectedRepoToOrgSecret

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
type ActionsAddSelectedRepoToOrgSecretResponse struct {
	common.Response
	request *ActionsAddSelectedRepoToOrgSecretReq
}

/*
ActionsCancelWorkflowRun performs requests for "actions/cancel-workflow-run"

Cancel a workflow run.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
func ActionsCancelWorkflowRun(ctx context.Context, req *ActionsCancelWorkflowRunReq, opt ...options.Option) (*ActionsCancelWorkflowRunResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsCancelWorkflowRunReq)
	}
	resp := &ActionsCancelWorkflowRunResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCancelWorkflowRun performs requests for "actions/cancel-workflow-run"

Cancel a workflow run.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
func (c Client) ActionsCancelWorkflowRun(ctx context.Context, req *ActionsCancelWorkflowRunReq, opt ...options.Option) (*ActionsCancelWorkflowRunResponse, error) {
	return ActionsCancelWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsCancelWorkflowRunReq is request data for Client.ActionsCancelWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
type ActionsCancelWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsCancelWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsCancelWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "POST",
		OperationID:      "actions/cancel-workflow-run",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runs/%v/cancel", r.Owner, r.Repo, r.RunId),
		URLQuery:         query,
		ValidStatuses:    []int{202},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCancelWorkflowRunReq) Rel(link RelName, resp *ActionsCancelWorkflowRunResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCancelWorkflowRunResponse is a response for ActionsCancelWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
type ActionsCancelWorkflowRunResponse struct {
	common.Response
	request *ActionsCancelWorkflowRunReq
}

/*
ActionsCreateOrUpdateOrgSecret performs requests for "actions/create-or-update-org-secret"

Create or update an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
func ActionsCreateOrUpdateOrgSecret(ctx context.Context, req *ActionsCreateOrUpdateOrgSecretReq, opt ...options.Option) (*ActionsCreateOrUpdateOrgSecretResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsCreateOrUpdateOrgSecretReq)
	}
	resp := &ActionsCreateOrUpdateOrgSecretResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateOrUpdateOrgSecret performs requests for "actions/create-or-update-org-secret"

Create or update an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
func (c Client) ActionsCreateOrUpdateOrgSecret(ctx context.Context, req *ActionsCreateOrUpdateOrgSecretReq, opt ...options.Option) (*ActionsCreateOrUpdateOrgSecretResponse, error) {
	return ActionsCreateOrUpdateOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateOrUpdateOrgSecretReq is request data for Client.ActionsCreateOrUpdateOrgSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type ActionsCreateOrUpdateOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName  string
	RequestBody ActionsCreateOrUpdateOrgSecretReqBody
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateOrUpdateOrgSecretReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsCreateOrUpdateOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "PUT",
		OperationID:      "actions/create-or-update-org-secret",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName),
		URLQuery:         query,
		ValidStatuses:    []int{201, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateOrUpdateOrgSecretReq) Rel(link RelName, resp *ActionsCreateOrUpdateOrgSecretResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateOrUpdateOrgSecretReqBody is a request body for actions/create-or-update-org-secret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type ActionsCreateOrUpdateOrgSecretReqBody struct {

	/*
	Value for your secret, encrypted with
	[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using
	the public key retrieved from the [Get an organization public
	key](https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key)
	endpoint.
	*/
	EncryptedValue *string `json:"encrypted_value,omitempty"`

	// ID of the key you used to encrypt the secret.
	KeyId *string `json:"key_id,omitempty"`

	/*
	An array of repository ids that can access the organization secret. You can only
	provide a list of repository ids when the `visibility` is set to `selected`. You
	can manage the list of selected repositories using the [List selected
	repositories for an organization
	secret](https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret),
	[Set selected repositories for an organization
	secret](https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret),
	and [Remove selected repository from an organization
	secret](https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret)
	endpoints.
	*/
	SelectedRepositoryIds []string `json:"selected_repository_ids,omitempty"`

	/*
	Configures the access that repositories have to the organization secret. Can be
	one of:
	\- `all` - All repositories in an organization can access the secret.
	\- `private` - Private repositories in an organization can access the secret.
	\- `selected` - Only specific repositories can access the secret.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ActionsCreateOrUpdateOrgSecretResponse is a response for ActionsCreateOrUpdateOrgSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type ActionsCreateOrUpdateOrgSecretResponse struct {
	common.Response
	request *ActionsCreateOrUpdateOrgSecretReq
}

/*
ActionsCreateOrUpdateRepoSecret performs requests for "actions/create-or-update-repo-secret"

Create or update a repository secret.

  PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
func ActionsCreateOrUpdateRepoSecret(ctx context.Context, req *ActionsCreateOrUpdateRepoSecretReq, opt ...options.Option) (*ActionsCreateOrUpdateRepoSecretResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsCreateOrUpdateRepoSecretReq)
	}
	resp := &ActionsCreateOrUpdateRepoSecretResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateOrUpdateRepoSecret performs requests for "actions/create-or-update-repo-secret"

Create or update a repository secret.

  PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
func (c Client) ActionsCreateOrUpdateRepoSecret(ctx context.Context, req *ActionsCreateOrUpdateRepoSecretReq, opt ...options.Option) (*ActionsCreateOrUpdateRepoSecretResponse, error) {
	return ActionsCreateOrUpdateRepoSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateOrUpdateRepoSecretReq is request data for Client.ActionsCreateOrUpdateRepoSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type ActionsCreateOrUpdateRepoSecretReq struct {
	_url  string
	Owner string
	Repo  string

	// secret_name parameter
	SecretName  string
	RequestBody ActionsCreateOrUpdateRepoSecretReqBody
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateOrUpdateRepoSecretReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsCreateOrUpdateRepoSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "PUT",
		OperationID:      "actions/create-or-update-repo-secret",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName),
		URLQuery:         query,
		ValidStatuses:    []int{201, 204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateOrUpdateRepoSecretReq) Rel(link RelName, resp *ActionsCreateOrUpdateRepoSecretResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateOrUpdateRepoSecretReqBody is a request body for actions/create-or-update-repo-secret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type ActionsCreateOrUpdateRepoSecretReqBody struct {

	/*
	Value for your secret, encrypted with
	[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using
	the public key retrieved from the [Get a repository public
	key](https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key)
	endpoint.
	*/
	EncryptedValue *string `json:"encrypted_value,omitempty"`

	// ID of the key you used to encrypt the secret.
	KeyId *string `json:"key_id,omitempty"`
}

/*
ActionsCreateOrUpdateRepoSecretResponse is a response for ActionsCreateOrUpdateRepoSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type ActionsCreateOrUpdateRepoSecretResponse struct {
	common.Response
	request *ActionsCreateOrUpdateRepoSecretReq
}

/*
ActionsCreateRegistrationTokenForOrg performs requests for "actions/create-registration-token-for-org"

Create a registration token for an organization.

  POST /orgs/{org}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
func ActionsCreateRegistrationTokenForOrg(ctx context.Context, req *ActionsCreateRegistrationTokenForOrgReq, opt ...options.Option) (*ActionsCreateRegistrationTokenForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsCreateRegistrationTokenForOrgReq)
	}
	resp := &ActionsCreateRegistrationTokenForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.AuthenticationToken{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRegistrationTokenForOrg performs requests for "actions/create-registration-token-for-org"

Create a registration token for an organization.

  POST /orgs/{org}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
func (c Client) ActionsCreateRegistrationTokenForOrg(ctx context.Context, req *ActionsCreateRegistrationTokenForOrgReq, opt ...options.Option) (*ActionsCreateRegistrationTokenForOrgResponse, error) {
	return ActionsCreateRegistrationTokenForOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateRegistrationTokenForOrgReq is request data for Client.ActionsCreateRegistrationTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
type ActionsCreateRegistrationTokenForOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateRegistrationTokenForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsCreateRegistrationTokenForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{201},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "POST",
		OperationID:      "actions/create-registration-token-for-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/runners/registration-token", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRegistrationTokenForOrgReq) Rel(link RelName, resp *ActionsCreateRegistrationTokenForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateRegistrationTokenForOrgResponse is a response for ActionsCreateRegistrationTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
type ActionsCreateRegistrationTokenForOrgResponse struct {
	common.Response
	request *ActionsCreateRegistrationTokenForOrgReq
	Data    components.AuthenticationToken
}

/*
ActionsCreateRegistrationTokenForRepo performs requests for "actions/create-registration-token-for-repo"

Create a registration token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
func ActionsCreateRegistrationTokenForRepo(ctx context.Context, req *ActionsCreateRegistrationTokenForRepoReq, opt ...options.Option) (*ActionsCreateRegistrationTokenForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsCreateRegistrationTokenForRepoReq)
	}
	resp := &ActionsCreateRegistrationTokenForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.AuthenticationToken{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRegistrationTokenForRepo performs requests for "actions/create-registration-token-for-repo"

Create a registration token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
func (c Client) ActionsCreateRegistrationTokenForRepo(ctx context.Context, req *ActionsCreateRegistrationTokenForRepoReq, opt ...options.Option) (*ActionsCreateRegistrationTokenForRepoResponse, error) {
	return ActionsCreateRegistrationTokenForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateRegistrationTokenForRepoReq is request data for Client.ActionsCreateRegistrationTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
type ActionsCreateRegistrationTokenForRepoReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateRegistrationTokenForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsCreateRegistrationTokenForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{201},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "POST",
		OperationID:      "actions/create-registration-token-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runners/registration-token", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRegistrationTokenForRepoReq) Rel(link RelName, resp *ActionsCreateRegistrationTokenForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateRegistrationTokenForRepoResponse is a response for ActionsCreateRegistrationTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
type ActionsCreateRegistrationTokenForRepoResponse struct {
	common.Response
	request *ActionsCreateRegistrationTokenForRepoReq
	Data    components.AuthenticationToken
}

/*
ActionsCreateRemoveTokenForOrg performs requests for "actions/create-remove-token-for-org"

Create a remove token for an organization.

  POST /orgs/{org}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
func ActionsCreateRemoveTokenForOrg(ctx context.Context, req *ActionsCreateRemoveTokenForOrgReq, opt ...options.Option) (*ActionsCreateRemoveTokenForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsCreateRemoveTokenForOrgReq)
	}
	resp := &ActionsCreateRemoveTokenForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.AuthenticationToken{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRemoveTokenForOrg performs requests for "actions/create-remove-token-for-org"

Create a remove token for an organization.

  POST /orgs/{org}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
func (c Client) ActionsCreateRemoveTokenForOrg(ctx context.Context, req *ActionsCreateRemoveTokenForOrgReq, opt ...options.Option) (*ActionsCreateRemoveTokenForOrgResponse, error) {
	return ActionsCreateRemoveTokenForOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateRemoveTokenForOrgReq is request data for Client.ActionsCreateRemoveTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
type ActionsCreateRemoveTokenForOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateRemoveTokenForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsCreateRemoveTokenForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{201},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "POST",
		OperationID:      "actions/create-remove-token-for-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/runners/remove-token", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRemoveTokenForOrgReq) Rel(link RelName, resp *ActionsCreateRemoveTokenForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateRemoveTokenForOrgResponse is a response for ActionsCreateRemoveTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
type ActionsCreateRemoveTokenForOrgResponse struct {
	common.Response
	request *ActionsCreateRemoveTokenForOrgReq
	Data    components.AuthenticationToken
}

/*
ActionsCreateRemoveTokenForRepo performs requests for "actions/create-remove-token-for-repo"

Create a remove token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
func ActionsCreateRemoveTokenForRepo(ctx context.Context, req *ActionsCreateRemoveTokenForRepoReq, opt ...options.Option) (*ActionsCreateRemoveTokenForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsCreateRemoveTokenForRepoReq)
	}
	resp := &ActionsCreateRemoveTokenForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.AuthenticationToken{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRemoveTokenForRepo performs requests for "actions/create-remove-token-for-repo"

Create a remove token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
func (c Client) ActionsCreateRemoveTokenForRepo(ctx context.Context, req *ActionsCreateRemoveTokenForRepoReq, opt ...options.Option) (*ActionsCreateRemoveTokenForRepoResponse, error) {
	return ActionsCreateRemoveTokenForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateRemoveTokenForRepoReq is request data for Client.ActionsCreateRemoveTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
type ActionsCreateRemoveTokenForRepoReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateRemoveTokenForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsCreateRemoveTokenForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{201},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "POST",
		OperationID:      "actions/create-remove-token-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runners/remove-token", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRemoveTokenForRepoReq) Rel(link RelName, resp *ActionsCreateRemoveTokenForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateRemoveTokenForRepoResponse is a response for ActionsCreateRemoveTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
type ActionsCreateRemoveTokenForRepoResponse struct {
	common.Response
	request *ActionsCreateRemoveTokenForRepoReq
	Data    components.AuthenticationToken
}

/*
ActionsCreateWorkflowDispatch performs requests for "actions/create-workflow-dispatch"

Create a workflow dispatch event.

  POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
func ActionsCreateWorkflowDispatch(ctx context.Context, req *ActionsCreateWorkflowDispatchReq, opt ...options.Option) (*ActionsCreateWorkflowDispatchResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsCreateWorkflowDispatchReq)
	}
	resp := &ActionsCreateWorkflowDispatchResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateWorkflowDispatch performs requests for "actions/create-workflow-dispatch"

Create a workflow dispatch event.

  POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
func (c Client) ActionsCreateWorkflowDispatch(ctx context.Context, req *ActionsCreateWorkflowDispatchReq, opt ...options.Option) (*ActionsCreateWorkflowDispatchResponse, error) {
	return ActionsCreateWorkflowDispatch(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateWorkflowDispatchReq is request data for Client.ActionsCreateWorkflowDispatch

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
type ActionsCreateWorkflowDispatchReq struct {
	_url        string
	Owner       string
	Repo        string
	WorkflowId  int64
	RequestBody ActionsCreateWorkflowDispatchReqBody
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateWorkflowDispatchReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsCreateWorkflowDispatchReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "POST",
		OperationID:      "actions/create-workflow-dispatch",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/workflows/%v/dispatches", r.Owner, r.Repo, r.WorkflowId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateWorkflowDispatchReq) Rel(link RelName, resp *ActionsCreateWorkflowDispatchResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateWorkflowDispatchReqBody is a request body for actions/create-workflow-dispatch

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
type ActionsCreateWorkflowDispatchReqBody struct {

	/*
	Input keys and values configured in the workflow file. The maximum number of
	properties is 10. Any default properties configured in the workflow file will be
	used when `inputs` are omitted.
	*/
	Inputs map[string]string `json:"inputs,omitempty"`

	// The reference of the workflow run. The reference can be a branch, tag, or a commit SHA.
	Ref *string `json:"ref"`
}

/*
ActionsCreateWorkflowDispatchResponse is a response for ActionsCreateWorkflowDispatch

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
type ActionsCreateWorkflowDispatchResponse struct {
	common.Response
	request *ActionsCreateWorkflowDispatchReq
}

/*
ActionsDeleteArtifact performs requests for "actions/delete-artifact"

Delete an artifact.

  DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
func ActionsDeleteArtifact(ctx context.Context, req *ActionsDeleteArtifactReq, opt ...options.Option) (*ActionsDeleteArtifactResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsDeleteArtifactReq)
	}
	resp := &ActionsDeleteArtifactResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteArtifact performs requests for "actions/delete-artifact"

Delete an artifact.

  DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
func (c Client) ActionsDeleteArtifact(ctx context.Context, req *ActionsDeleteArtifactReq, opt ...options.Option) (*ActionsDeleteArtifactResponse, error) {
	return ActionsDeleteArtifact(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteArtifactReq is request data for Client.ActionsDeleteArtifact

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
type ActionsDeleteArtifactReq struct {
	_url  string
	Owner string
	Repo  string

	// artifact_id parameter
	ArtifactId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteArtifactReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsDeleteArtifactReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "actions/delete-artifact",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v", r.Owner, r.Repo, r.ArtifactId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteArtifactReq) Rel(link RelName, resp *ActionsDeleteArtifactResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteArtifactResponse is a response for ActionsDeleteArtifact

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
type ActionsDeleteArtifactResponse struct {
	common.Response
	request *ActionsDeleteArtifactReq
}

/*
ActionsDeleteOrgSecret performs requests for "actions/delete-org-secret"

Delete an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
func ActionsDeleteOrgSecret(ctx context.Context, req *ActionsDeleteOrgSecretReq, opt ...options.Option) (*ActionsDeleteOrgSecretResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsDeleteOrgSecretReq)
	}
	resp := &ActionsDeleteOrgSecretResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteOrgSecret performs requests for "actions/delete-org-secret"

Delete an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
func (c Client) ActionsDeleteOrgSecret(ctx context.Context, req *ActionsDeleteOrgSecretReq, opt ...options.Option) (*ActionsDeleteOrgSecretResponse, error) {
	return ActionsDeleteOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteOrgSecretReq is request data for Client.ActionsDeleteOrgSecret

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
type ActionsDeleteOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteOrgSecretReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsDeleteOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "actions/delete-org-secret",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteOrgSecretReq) Rel(link RelName, resp *ActionsDeleteOrgSecretResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteOrgSecretResponse is a response for ActionsDeleteOrgSecret

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
type ActionsDeleteOrgSecretResponse struct {
	common.Response
	request *ActionsDeleteOrgSecretReq
}

/*
ActionsDeleteRepoSecret performs requests for "actions/delete-repo-secret"

Delete a repository secret.

  DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
func ActionsDeleteRepoSecret(ctx context.Context, req *ActionsDeleteRepoSecretReq, opt ...options.Option) (*ActionsDeleteRepoSecretResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsDeleteRepoSecretReq)
	}
	resp := &ActionsDeleteRepoSecretResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteRepoSecret performs requests for "actions/delete-repo-secret"

Delete a repository secret.

  DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
func (c Client) ActionsDeleteRepoSecret(ctx context.Context, req *ActionsDeleteRepoSecretReq, opt ...options.Option) (*ActionsDeleteRepoSecretResponse, error) {
	return ActionsDeleteRepoSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteRepoSecretReq is request data for Client.ActionsDeleteRepoSecret

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
type ActionsDeleteRepoSecretReq struct {
	_url  string
	Owner string
	Repo  string

	// secret_name parameter
	SecretName string
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteRepoSecretReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsDeleteRepoSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "actions/delete-repo-secret",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteRepoSecretReq) Rel(link RelName, resp *ActionsDeleteRepoSecretResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteRepoSecretResponse is a response for ActionsDeleteRepoSecret

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
type ActionsDeleteRepoSecretResponse struct {
	common.Response
	request *ActionsDeleteRepoSecretReq
}

/*
ActionsDeleteSelfHostedRunnerFromOrg performs requests for "actions/delete-self-hosted-runner-from-org"

Delete a self-hosted runner from an organization.

  DELETE /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
func ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, req *ActionsDeleteSelfHostedRunnerFromOrgReq, opt ...options.Option) (*ActionsDeleteSelfHostedRunnerFromOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsDeleteSelfHostedRunnerFromOrgReq)
	}
	resp := &ActionsDeleteSelfHostedRunnerFromOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteSelfHostedRunnerFromOrg performs requests for "actions/delete-self-hosted-runner-from-org"

Delete a self-hosted runner from an organization.

  DELETE /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
func (c Client) ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, req *ActionsDeleteSelfHostedRunnerFromOrgReq, opt ...options.Option) (*ActionsDeleteSelfHostedRunnerFromOrgResponse, error) {
	return ActionsDeleteSelfHostedRunnerFromOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteSelfHostedRunnerFromOrgReq is request data for Client.ActionsDeleteSelfHostedRunnerFromOrg

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
type ActionsDeleteSelfHostedRunnerFromOrgReq struct {
	_url string
	Org  string

	// runner_id parameter
	RunnerId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "actions/delete-self-hosted-runner-from-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/runners/%v", r.Org, r.RunnerId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) Rel(link RelName, resp *ActionsDeleteSelfHostedRunnerFromOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteSelfHostedRunnerFromOrgResponse is a response for ActionsDeleteSelfHostedRunnerFromOrg

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
type ActionsDeleteSelfHostedRunnerFromOrgResponse struct {
	common.Response
	request *ActionsDeleteSelfHostedRunnerFromOrgReq
}

/*
ActionsDeleteSelfHostedRunnerFromRepo performs requests for "actions/delete-self-hosted-runner-from-repo"

Delete a self-hosted runner from a repository.

  DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
func ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, req *ActionsDeleteSelfHostedRunnerFromRepoReq, opt ...options.Option) (*ActionsDeleteSelfHostedRunnerFromRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsDeleteSelfHostedRunnerFromRepoReq)
	}
	resp := &ActionsDeleteSelfHostedRunnerFromRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteSelfHostedRunnerFromRepo performs requests for "actions/delete-self-hosted-runner-from-repo"

Delete a self-hosted runner from a repository.

  DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
func (c Client) ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, req *ActionsDeleteSelfHostedRunnerFromRepoReq, opt ...options.Option) (*ActionsDeleteSelfHostedRunnerFromRepoResponse, error) {
	return ActionsDeleteSelfHostedRunnerFromRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteSelfHostedRunnerFromRepoReq is request data for Client.ActionsDeleteSelfHostedRunnerFromRepo

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
type ActionsDeleteSelfHostedRunnerFromRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// runner_id parameter
	RunnerId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "actions/delete-self-hosted-runner-from-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runners/%v", r.Owner, r.Repo, r.RunnerId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) Rel(link RelName, resp *ActionsDeleteSelfHostedRunnerFromRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteSelfHostedRunnerFromRepoResponse is a response for ActionsDeleteSelfHostedRunnerFromRepo

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
type ActionsDeleteSelfHostedRunnerFromRepoResponse struct {
	common.Response
	request *ActionsDeleteSelfHostedRunnerFromRepoReq
}

/*
ActionsDeleteWorkflowRun performs requests for "actions/delete-workflow-run"

Delete a workflow run.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
func ActionsDeleteWorkflowRun(ctx context.Context, req *ActionsDeleteWorkflowRunReq, opt ...options.Option) (*ActionsDeleteWorkflowRunResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsDeleteWorkflowRunReq)
	}
	resp := &ActionsDeleteWorkflowRunResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteWorkflowRun performs requests for "actions/delete-workflow-run"

Delete a workflow run.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
func (c Client) ActionsDeleteWorkflowRun(ctx context.Context, req *ActionsDeleteWorkflowRunReq, opt ...options.Option) (*ActionsDeleteWorkflowRunResponse, error) {
	return ActionsDeleteWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteWorkflowRunReq is request data for Client.ActionsDeleteWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
type ActionsDeleteWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsDeleteWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "actions/delete-workflow-run",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runs/%v", r.Owner, r.Repo, r.RunId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteWorkflowRunReq) Rel(link RelName, resp *ActionsDeleteWorkflowRunResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteWorkflowRunResponse is a response for ActionsDeleteWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
type ActionsDeleteWorkflowRunResponse struct {
	common.Response
	request *ActionsDeleteWorkflowRunReq
}

/*
ActionsDeleteWorkflowRunLogs performs requests for "actions/delete-workflow-run-logs"

Delete workflow run logs.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
func ActionsDeleteWorkflowRunLogs(ctx context.Context, req *ActionsDeleteWorkflowRunLogsReq, opt ...options.Option) (*ActionsDeleteWorkflowRunLogsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsDeleteWorkflowRunLogsReq)
	}
	resp := &ActionsDeleteWorkflowRunLogsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteWorkflowRunLogs performs requests for "actions/delete-workflow-run-logs"

Delete workflow run logs.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
func (c Client) ActionsDeleteWorkflowRunLogs(ctx context.Context, req *ActionsDeleteWorkflowRunLogsReq, opt ...options.Option) (*ActionsDeleteWorkflowRunLogsResponse, error) {
	return ActionsDeleteWorkflowRunLogs(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteWorkflowRunLogsReq is request data for Client.ActionsDeleteWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
type ActionsDeleteWorkflowRunLogsReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteWorkflowRunLogsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsDeleteWorkflowRunLogsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "actions/delete-workflow-run-logs",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runs/%v/logs", r.Owner, r.Repo, r.RunId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteWorkflowRunLogsReq) Rel(link RelName, resp *ActionsDeleteWorkflowRunLogsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteWorkflowRunLogsResponse is a response for ActionsDeleteWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
type ActionsDeleteWorkflowRunLogsResponse struct {
	common.Response
	request *ActionsDeleteWorkflowRunLogsReq
}

/*
ActionsDownloadArtifact performs requests for "actions/download-artifact"

Download an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
func ActionsDownloadArtifact(ctx context.Context, req *ActionsDownloadArtifactReq, opt ...options.Option) (*ActionsDownloadArtifactResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsDownloadArtifactReq)
	}
	resp := &ActionsDownloadArtifactResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDownloadArtifact performs requests for "actions/download-artifact"

Download an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
func (c Client) ActionsDownloadArtifact(ctx context.Context, req *ActionsDownloadArtifactReq, opt ...options.Option) (*ActionsDownloadArtifactResponse, error) {
	return ActionsDownloadArtifact(ctx, req, append(c, opt...)...)
}

/*
ActionsDownloadArtifactReq is request data for Client.ActionsDownloadArtifact

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
type ActionsDownloadArtifactReq struct {
	_url  string
	Owner string
	Repo  string

	// artifact_id parameter
	ArtifactId int64

	// archive_format parameter
	ArchiveFormat string
}

// HTTPRequest builds an *http.Request
func (r *ActionsDownloadArtifactReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsDownloadArtifactReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "actions/download-artifact",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v/%v", r.Owner, r.Repo, r.ArtifactId, r.ArchiveFormat),
		URLQuery:         query,
		ValidStatuses:    []int{302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDownloadArtifactReq) Rel(link RelName, resp *ActionsDownloadArtifactResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDownloadArtifactResponse is a response for ActionsDownloadArtifact

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
type ActionsDownloadArtifactResponse struct {
	common.Response
	request *ActionsDownloadArtifactReq
}

/*
ActionsDownloadJobLogsForWorkflowRun performs requests for "actions/download-job-logs-for-workflow-run"

Download job logs for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
func ActionsDownloadJobLogsForWorkflowRun(ctx context.Context, req *ActionsDownloadJobLogsForWorkflowRunReq, opt ...options.Option) (*ActionsDownloadJobLogsForWorkflowRunResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsDownloadJobLogsForWorkflowRunReq)
	}
	resp := &ActionsDownloadJobLogsForWorkflowRunResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDownloadJobLogsForWorkflowRun performs requests for "actions/download-job-logs-for-workflow-run"

Download job logs for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
func (c Client) ActionsDownloadJobLogsForWorkflowRun(ctx context.Context, req *ActionsDownloadJobLogsForWorkflowRunReq, opt ...options.Option) (*ActionsDownloadJobLogsForWorkflowRunResponse, error) {
	return ActionsDownloadJobLogsForWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsDownloadJobLogsForWorkflowRunReq is request data for Client.ActionsDownloadJobLogsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
type ActionsDownloadJobLogsForWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string

	// job_id parameter
	JobId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsDownloadJobLogsForWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsDownloadJobLogsForWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "actions/download-job-logs-for-workflow-run",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/jobs/%v/logs", r.Owner, r.Repo, r.JobId),
		URLQuery:         query,
		ValidStatuses:    []int{302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDownloadJobLogsForWorkflowRunReq) Rel(link RelName, resp *ActionsDownloadJobLogsForWorkflowRunResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDownloadJobLogsForWorkflowRunResponse is a response for ActionsDownloadJobLogsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
type ActionsDownloadJobLogsForWorkflowRunResponse struct {
	common.Response
	request *ActionsDownloadJobLogsForWorkflowRunReq
}

/*
ActionsDownloadWorkflowRunLogs performs requests for "actions/download-workflow-run-logs"

Download workflow run logs.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
func ActionsDownloadWorkflowRunLogs(ctx context.Context, req *ActionsDownloadWorkflowRunLogsReq, opt ...options.Option) (*ActionsDownloadWorkflowRunLogsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsDownloadWorkflowRunLogsReq)
	}
	resp := &ActionsDownloadWorkflowRunLogsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDownloadWorkflowRunLogs performs requests for "actions/download-workflow-run-logs"

Download workflow run logs.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
func (c Client) ActionsDownloadWorkflowRunLogs(ctx context.Context, req *ActionsDownloadWorkflowRunLogsReq, opt ...options.Option) (*ActionsDownloadWorkflowRunLogsResponse, error) {
	return ActionsDownloadWorkflowRunLogs(ctx, req, append(c, opt...)...)
}

/*
ActionsDownloadWorkflowRunLogsReq is request data for Client.ActionsDownloadWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
type ActionsDownloadWorkflowRunLogsReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsDownloadWorkflowRunLogsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsDownloadWorkflowRunLogsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "GET",
		OperationID:      "actions/download-workflow-run-logs",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runs/%v/logs", r.Owner, r.Repo, r.RunId),
		URLQuery:         query,
		ValidStatuses:    []int{302},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDownloadWorkflowRunLogsReq) Rel(link RelName, resp *ActionsDownloadWorkflowRunLogsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDownloadWorkflowRunLogsResponse is a response for ActionsDownloadWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
type ActionsDownloadWorkflowRunLogsResponse struct {
	common.Response
	request *ActionsDownloadWorkflowRunLogsReq
}

/*
ActionsGetArtifact performs requests for "actions/get-artifact"

Get an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
func ActionsGetArtifact(ctx context.Context, req *ActionsGetArtifactReq, opt ...options.Option) (*ActionsGetArtifactResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetArtifactReq)
	}
	resp := &ActionsGetArtifactResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Artifact{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetArtifact performs requests for "actions/get-artifact"

Get an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
func (c Client) ActionsGetArtifact(ctx context.Context, req *ActionsGetArtifactReq, opt ...options.Option) (*ActionsGetArtifactResponse, error) {
	return ActionsGetArtifact(ctx, req, append(c, opt...)...)
}

/*
ActionsGetArtifactReq is request data for Client.ActionsGetArtifact

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
type ActionsGetArtifactReq struct {
	_url  string
	Owner string
	Repo  string

	// artifact_id parameter
	ArtifactId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetArtifactReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetArtifactReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-artifact",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v", r.Owner, r.Repo, r.ArtifactId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetArtifactReq) Rel(link RelName, resp *ActionsGetArtifactResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetArtifactResponse is a response for ActionsGetArtifact

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
type ActionsGetArtifactResponse struct {
	common.Response
	request *ActionsGetArtifactReq
	Data    components.Artifact
}

/*
ActionsGetJobForWorkflowRun performs requests for "actions/get-job-for-workflow-run"

Get a job for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
func ActionsGetJobForWorkflowRun(ctx context.Context, req *ActionsGetJobForWorkflowRunReq, opt ...options.Option) (*ActionsGetJobForWorkflowRunResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetJobForWorkflowRunReq)
	}
	resp := &ActionsGetJobForWorkflowRunResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Job{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetJobForWorkflowRun performs requests for "actions/get-job-for-workflow-run"

Get a job for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
func (c Client) ActionsGetJobForWorkflowRun(ctx context.Context, req *ActionsGetJobForWorkflowRunReq, opt ...options.Option) (*ActionsGetJobForWorkflowRunResponse, error) {
	return ActionsGetJobForWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsGetJobForWorkflowRunReq is request data for Client.ActionsGetJobForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
type ActionsGetJobForWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string

	// job_id parameter
	JobId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetJobForWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetJobForWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{202},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-job-for-workflow-run",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/jobs/%v", r.Owner, r.Repo, r.JobId),
		URLQuery:         query,
		ValidStatuses:    []int{202},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetJobForWorkflowRunReq) Rel(link RelName, resp *ActionsGetJobForWorkflowRunResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetJobForWorkflowRunResponse is a response for ActionsGetJobForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
type ActionsGetJobForWorkflowRunResponse struct {
	common.Response
	request *ActionsGetJobForWorkflowRunReq
	Data    components.Job
}

/*
ActionsGetOrgPublicKey performs requests for "actions/get-org-public-key"

Get an organization public key.

  GET /orgs/{org}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
func ActionsGetOrgPublicKey(ctx context.Context, req *ActionsGetOrgPublicKeyReq, opt ...options.Option) (*ActionsGetOrgPublicKeyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetOrgPublicKeyReq)
	}
	resp := &ActionsGetOrgPublicKeyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ActionsPublicKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetOrgPublicKey performs requests for "actions/get-org-public-key"

Get an organization public key.

  GET /orgs/{org}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
func (c Client) ActionsGetOrgPublicKey(ctx context.Context, req *ActionsGetOrgPublicKeyReq, opt ...options.Option) (*ActionsGetOrgPublicKeyResponse, error) {
	return ActionsGetOrgPublicKey(ctx, req, append(c, opt...)...)
}

/*
ActionsGetOrgPublicKeyReq is request data for Client.ActionsGetOrgPublicKey

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
type ActionsGetOrgPublicKeyReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetOrgPublicKeyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetOrgPublicKeyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-org-public-key",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/secrets/public-key", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetOrgPublicKeyReq) Rel(link RelName, resp *ActionsGetOrgPublicKeyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetOrgPublicKeyResponse is a response for ActionsGetOrgPublicKey

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
type ActionsGetOrgPublicKeyResponse struct {
	common.Response
	request *ActionsGetOrgPublicKeyReq
	Data    components.ActionsPublicKey
}

/*
ActionsGetOrgSecret performs requests for "actions/get-org-secret"

Get an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
func ActionsGetOrgSecret(ctx context.Context, req *ActionsGetOrgSecretReq, opt ...options.Option) (*ActionsGetOrgSecretResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetOrgSecretReq)
	}
	resp := &ActionsGetOrgSecretResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.OrganizationActionsSecret{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetOrgSecret performs requests for "actions/get-org-secret"

Get an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
func (c Client) ActionsGetOrgSecret(ctx context.Context, req *ActionsGetOrgSecretReq, opt ...options.Option) (*ActionsGetOrgSecretResponse, error) {
	return ActionsGetOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsGetOrgSecretReq is request data for Client.ActionsGetOrgSecret

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
type ActionsGetOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetOrgSecretReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-org-secret",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetOrgSecretReq) Rel(link RelName, resp *ActionsGetOrgSecretResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetOrgSecretResponse is a response for ActionsGetOrgSecret

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
type ActionsGetOrgSecretResponse struct {
	common.Response
	request *ActionsGetOrgSecretReq
	Data    components.OrganizationActionsSecret
}

/*
ActionsGetRepoPublicKey performs requests for "actions/get-repo-public-key"

Get a repository public key.

  GET /repos/{owner}/{repo}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
func ActionsGetRepoPublicKey(ctx context.Context, req *ActionsGetRepoPublicKeyReq, opt ...options.Option) (*ActionsGetRepoPublicKeyResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetRepoPublicKeyReq)
	}
	resp := &ActionsGetRepoPublicKeyResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ActionsPublicKey{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetRepoPublicKey performs requests for "actions/get-repo-public-key"

Get a repository public key.

  GET /repos/{owner}/{repo}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
func (c Client) ActionsGetRepoPublicKey(ctx context.Context, req *ActionsGetRepoPublicKeyReq, opt ...options.Option) (*ActionsGetRepoPublicKeyResponse, error) {
	return ActionsGetRepoPublicKey(ctx, req, append(c, opt...)...)
}

/*
ActionsGetRepoPublicKeyReq is request data for Client.ActionsGetRepoPublicKey

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
type ActionsGetRepoPublicKeyReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetRepoPublicKeyReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetRepoPublicKeyReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-repo-public-key",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/secrets/public-key", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetRepoPublicKeyReq) Rel(link RelName, resp *ActionsGetRepoPublicKeyResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetRepoPublicKeyResponse is a response for ActionsGetRepoPublicKey

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
type ActionsGetRepoPublicKeyResponse struct {
	common.Response
	request *ActionsGetRepoPublicKeyReq
	Data    components.ActionsPublicKey
}

/*
ActionsGetRepoSecret performs requests for "actions/get-repo-secret"

Get a repository secret.

  GET /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
func ActionsGetRepoSecret(ctx context.Context, req *ActionsGetRepoSecretReq, opt ...options.Option) (*ActionsGetRepoSecretResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetRepoSecretReq)
	}
	resp := &ActionsGetRepoSecretResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.ActionsSecret{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetRepoSecret performs requests for "actions/get-repo-secret"

Get a repository secret.

  GET /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
func (c Client) ActionsGetRepoSecret(ctx context.Context, req *ActionsGetRepoSecretReq, opt ...options.Option) (*ActionsGetRepoSecretResponse, error) {
	return ActionsGetRepoSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsGetRepoSecretReq is request data for Client.ActionsGetRepoSecret

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
type ActionsGetRepoSecretReq struct {
	_url  string
	Owner string
	Repo  string

	// secret_name parameter
	SecretName string
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetRepoSecretReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetRepoSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-repo-secret",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetRepoSecretReq) Rel(link RelName, resp *ActionsGetRepoSecretResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetRepoSecretResponse is a response for ActionsGetRepoSecret

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
type ActionsGetRepoSecretResponse struct {
	common.Response
	request *ActionsGetRepoSecretReq
	Data    components.ActionsSecret
}

/*
ActionsGetSelfHostedRunnerForOrg performs requests for "actions/get-self-hosted-runner-for-org"

Get a self-hosted runner for an organization.

  GET /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
func ActionsGetSelfHostedRunnerForOrg(ctx context.Context, req *ActionsGetSelfHostedRunnerForOrgReq, opt ...options.Option) (*ActionsGetSelfHostedRunnerForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetSelfHostedRunnerForOrgReq)
	}
	resp := &ActionsGetSelfHostedRunnerForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Runner{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetSelfHostedRunnerForOrg performs requests for "actions/get-self-hosted-runner-for-org"

Get a self-hosted runner for an organization.

  GET /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
func (c Client) ActionsGetSelfHostedRunnerForOrg(ctx context.Context, req *ActionsGetSelfHostedRunnerForOrgReq, opt ...options.Option) (*ActionsGetSelfHostedRunnerForOrgResponse, error) {
	return ActionsGetSelfHostedRunnerForOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsGetSelfHostedRunnerForOrgReq is request data for Client.ActionsGetSelfHostedRunnerForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
type ActionsGetSelfHostedRunnerForOrgReq struct {
	_url string
	Org  string

	// runner_id parameter
	RunnerId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetSelfHostedRunnerForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-self-hosted-runner-for-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/runners/%v", r.Org, r.RunnerId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetSelfHostedRunnerForOrgReq) Rel(link RelName, resp *ActionsGetSelfHostedRunnerForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetSelfHostedRunnerForOrgResponse is a response for ActionsGetSelfHostedRunnerForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
type ActionsGetSelfHostedRunnerForOrgResponse struct {
	common.Response
	request *ActionsGetSelfHostedRunnerForOrgReq
	Data    components.Runner
}

/*
ActionsGetSelfHostedRunnerForRepo performs requests for "actions/get-self-hosted-runner-for-repo"

Get a self-hosted runner for a repository.

  GET /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
func ActionsGetSelfHostedRunnerForRepo(ctx context.Context, req *ActionsGetSelfHostedRunnerForRepoReq, opt ...options.Option) (*ActionsGetSelfHostedRunnerForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetSelfHostedRunnerForRepoReq)
	}
	resp := &ActionsGetSelfHostedRunnerForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Runner{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetSelfHostedRunnerForRepo performs requests for "actions/get-self-hosted-runner-for-repo"

Get a self-hosted runner for a repository.

  GET /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
func (c Client) ActionsGetSelfHostedRunnerForRepo(ctx context.Context, req *ActionsGetSelfHostedRunnerForRepoReq, opt ...options.Option) (*ActionsGetSelfHostedRunnerForRepoResponse, error) {
	return ActionsGetSelfHostedRunnerForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsGetSelfHostedRunnerForRepoReq is request data for Client.ActionsGetSelfHostedRunnerForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
type ActionsGetSelfHostedRunnerForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// runner_id parameter
	RunnerId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetSelfHostedRunnerForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-self-hosted-runner-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runners/%v", r.Owner, r.Repo, r.RunnerId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetSelfHostedRunnerForRepoReq) Rel(link RelName, resp *ActionsGetSelfHostedRunnerForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetSelfHostedRunnerForRepoResponse is a response for ActionsGetSelfHostedRunnerForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
type ActionsGetSelfHostedRunnerForRepoResponse struct {
	common.Response
	request *ActionsGetSelfHostedRunnerForRepoReq
	Data    components.Runner
}

/*
ActionsGetWorkflow performs requests for "actions/get-workflow"

Get a workflow.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
func ActionsGetWorkflow(ctx context.Context, req *ActionsGetWorkflowReq, opt ...options.Option) (*ActionsGetWorkflowResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetWorkflowReq)
	}
	resp := &ActionsGetWorkflowResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.Workflow{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflow performs requests for "actions/get-workflow"

Get a workflow.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
func (c Client) ActionsGetWorkflow(ctx context.Context, req *ActionsGetWorkflowReq, opt ...options.Option) (*ActionsGetWorkflowResponse, error) {
	return ActionsGetWorkflow(ctx, req, append(c, opt...)...)
}

/*
ActionsGetWorkflowReq is request data for Client.ActionsGetWorkflow

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
type ActionsGetWorkflowReq struct {
	_url       string
	Owner      string
	Repo       string
	WorkflowId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetWorkflowReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetWorkflowReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-workflow",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/workflows/%v", r.Owner, r.Repo, r.WorkflowId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowReq) Rel(link RelName, resp *ActionsGetWorkflowResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetWorkflowResponse is a response for ActionsGetWorkflow

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
type ActionsGetWorkflowResponse struct {
	common.Response
	request *ActionsGetWorkflowReq
	Data    components.Workflow
}

/*
ActionsGetWorkflowRun performs requests for "actions/get-workflow-run"

Get a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
func ActionsGetWorkflowRun(ctx context.Context, req *ActionsGetWorkflowRunReq, opt ...options.Option) (*ActionsGetWorkflowRunResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetWorkflowRunReq)
	}
	resp := &ActionsGetWorkflowRunResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.WorkflowRun{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflowRun performs requests for "actions/get-workflow-run"

Get a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
func (c Client) ActionsGetWorkflowRun(ctx context.Context, req *ActionsGetWorkflowRunReq, opt ...options.Option) (*ActionsGetWorkflowRunResponse, error) {
	return ActionsGetWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsGetWorkflowRunReq is request data for Client.ActionsGetWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
type ActionsGetWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-workflow-run",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runs/%v", r.Owner, r.Repo, r.RunId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowRunReq) Rel(link RelName, resp *ActionsGetWorkflowRunResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetWorkflowRunResponse is a response for ActionsGetWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
type ActionsGetWorkflowRunResponse struct {
	common.Response
	request *ActionsGetWorkflowRunReq
	Data    components.WorkflowRun
}

/*
ActionsGetWorkflowRunUsage performs requests for "actions/get-workflow-run-usage"

Get workflow run usage.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
func ActionsGetWorkflowRunUsage(ctx context.Context, req *ActionsGetWorkflowRunUsageReq, opt ...options.Option) (*ActionsGetWorkflowRunUsageResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetWorkflowRunUsageReq)
	}
	resp := &ActionsGetWorkflowRunUsageResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.WorkflowRunUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflowRunUsage performs requests for "actions/get-workflow-run-usage"

Get workflow run usage.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
func (c Client) ActionsGetWorkflowRunUsage(ctx context.Context, req *ActionsGetWorkflowRunUsageReq, opt ...options.Option) (*ActionsGetWorkflowRunUsageResponse, error) {
	return ActionsGetWorkflowRunUsage(ctx, req, append(c, opt...)...)
}

/*
ActionsGetWorkflowRunUsageReq is request data for Client.ActionsGetWorkflowRunUsage

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
type ActionsGetWorkflowRunUsageReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetWorkflowRunUsageReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetWorkflowRunUsageReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-workflow-run-usage",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runs/%v/timing", r.Owner, r.Repo, r.RunId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowRunUsageReq) Rel(link RelName, resp *ActionsGetWorkflowRunUsageResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetWorkflowRunUsageResponse is a response for ActionsGetWorkflowRunUsage

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
type ActionsGetWorkflowRunUsageResponse struct {
	common.Response
	request *ActionsGetWorkflowRunUsageReq
	Data    components.WorkflowRunUsage
}

/*
ActionsGetWorkflowUsage performs requests for "actions/get-workflow-usage"

Get workflow usage.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
func ActionsGetWorkflowUsage(ctx context.Context, req *ActionsGetWorkflowUsageReq, opt ...options.Option) (*ActionsGetWorkflowUsageResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsGetWorkflowUsageReq)
	}
	resp := &ActionsGetWorkflowUsageResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = components.WorkflowUsage{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflowUsage performs requests for "actions/get-workflow-usage"

Get workflow usage.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
func (c Client) ActionsGetWorkflowUsage(ctx context.Context, req *ActionsGetWorkflowUsageReq, opt ...options.Option) (*ActionsGetWorkflowUsageResponse, error) {
	return ActionsGetWorkflowUsage(ctx, req, append(c, opt...)...)
}

/*
ActionsGetWorkflowUsageReq is request data for Client.ActionsGetWorkflowUsage

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
type ActionsGetWorkflowUsageReq struct {
	_url       string
	Owner      string
	Repo       string
	WorkflowId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetWorkflowUsageReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsGetWorkflowUsageReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/get-workflow-usage",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/workflows/%v/timing", r.Owner, r.Repo, r.WorkflowId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowUsageReq) Rel(link RelName, resp *ActionsGetWorkflowUsageResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetWorkflowUsageResponse is a response for ActionsGetWorkflowUsage

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
type ActionsGetWorkflowUsageResponse struct {
	common.Response
	request *ActionsGetWorkflowUsageReq
	Data    components.WorkflowUsage
}

/*
ActionsListArtifactsForRepo performs requests for "actions/list-artifacts-for-repo"

List artifacts for a repository.

  GET /repos/{owner}/{repo}/actions/artifacts

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
func ActionsListArtifactsForRepo(ctx context.Context, req *ActionsListArtifactsForRepoReq, opt ...options.Option) (*ActionsListArtifactsForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListArtifactsForRepoReq)
	}
	resp := &ActionsListArtifactsForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActionsListArtifactsForRepoResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListArtifactsForRepo performs requests for "actions/list-artifacts-for-repo"

List artifacts for a repository.

  GET /repos/{owner}/{repo}/actions/artifacts

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
func (c Client) ActionsListArtifactsForRepo(ctx context.Context, req *ActionsListArtifactsForRepoReq, opt ...options.Option) (*ActionsListArtifactsForRepoResponse, error) {
	return ActionsListArtifactsForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsListArtifactsForRepoReq is request data for Client.ActionsListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ActionsListArtifactsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsListArtifactsForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListArtifactsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-artifacts-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/artifacts", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListArtifactsForRepoReq) Rel(link RelName, resp *ActionsListArtifactsForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListArtifactsForRepoResponseBody is a response body for ActionsListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ActionsListArtifactsForRepoResponseBody struct {
	Artifacts  []components.Artifact `json:"artifacts,omitempty"`
	TotalCount int64                 `json:"total_count,omitempty"`
}

/*
ActionsListArtifactsForRepoResponse is a response for ActionsListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ActionsListArtifactsForRepoResponse struct {
	common.Response
	request *ActionsListArtifactsForRepoReq
	Data    ActionsListArtifactsForRepoResponseBody
}

/*
ActionsListJobsForWorkflowRun performs requests for "actions/list-jobs-for-workflow-run"

List jobs for a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
func ActionsListJobsForWorkflowRun(ctx context.Context, req *ActionsListJobsForWorkflowRunReq, opt ...options.Option) (*ActionsListJobsForWorkflowRunResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListJobsForWorkflowRunReq)
	}
	resp := &ActionsListJobsForWorkflowRunResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActionsListJobsForWorkflowRunResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListJobsForWorkflowRun performs requests for "actions/list-jobs-for-workflow-run"

List jobs for a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
func (c Client) ActionsListJobsForWorkflowRun(ctx context.Context, req *ActionsListJobsForWorkflowRunReq, opt ...options.Option) (*ActionsListJobsForWorkflowRunResponse, error) {
	return ActionsListJobsForWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsListJobsForWorkflowRunReq is request data for Client.ActionsListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ActionsListJobsForWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64

	/*
	Filters jobs by their `completed_at` timestamp. Can be one of:
	\* `latest`: Returns jobs from the most recent execution of the workflow run.
	\* `all`: Returns all jobs for a workflow run, including from old executions of
	the workflow run.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsListJobsForWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListJobsForWorkflowRunReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-jobs-for-workflow-run",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runs/%v/jobs", r.Owner, r.Repo, r.RunId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListJobsForWorkflowRunReq) Rel(link RelName, resp *ActionsListJobsForWorkflowRunResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListJobsForWorkflowRunResponseBody is a response body for ActionsListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ActionsListJobsForWorkflowRunResponseBody struct {
	Jobs       []components.Job `json:"jobs,omitempty"`
	TotalCount int64            `json:"total_count,omitempty"`
}

/*
ActionsListJobsForWorkflowRunResponse is a response for ActionsListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ActionsListJobsForWorkflowRunResponse struct {
	common.Response
	request *ActionsListJobsForWorkflowRunReq
	Data    ActionsListJobsForWorkflowRunResponseBody
}

/*
ActionsListOrgSecrets performs requests for "actions/list-org-secrets"

List organization secrets.

  GET /orgs/{org}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
func ActionsListOrgSecrets(ctx context.Context, req *ActionsListOrgSecretsReq, opt ...options.Option) (*ActionsListOrgSecretsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListOrgSecretsReq)
	}
	resp := &ActionsListOrgSecretsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActionsListOrgSecretsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListOrgSecrets performs requests for "actions/list-org-secrets"

List organization secrets.

  GET /orgs/{org}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
func (c Client) ActionsListOrgSecrets(ctx context.Context, req *ActionsListOrgSecretsReq, opt ...options.Option) (*ActionsListOrgSecretsResponse, error) {
	return ActionsListOrgSecrets(ctx, req, append(c, opt...)...)
}

/*
ActionsListOrgSecretsReq is request data for Client.ActionsListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ActionsListOrgSecretsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsListOrgSecretsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListOrgSecretsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-org-secrets",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/secrets", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListOrgSecretsReq) Rel(link RelName, resp *ActionsListOrgSecretsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListOrgSecretsResponseBody is a response body for ActionsListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ActionsListOrgSecretsResponseBody struct {
	Secrets    []components.OrganizationActionsSecret `json:"secrets,omitempty"`
	TotalCount int64                                  `json:"total_count,omitempty"`
}

/*
ActionsListOrgSecretsResponse is a response for ActionsListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ActionsListOrgSecretsResponse struct {
	common.Response
	request *ActionsListOrgSecretsReq
	Data    ActionsListOrgSecretsResponseBody
}

/*
ActionsListRepoSecrets performs requests for "actions/list-repo-secrets"

List repository secrets.

  GET /repos/{owner}/{repo}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
func ActionsListRepoSecrets(ctx context.Context, req *ActionsListRepoSecretsReq, opt ...options.Option) (*ActionsListRepoSecretsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListRepoSecretsReq)
	}
	resp := &ActionsListRepoSecretsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActionsListRepoSecretsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRepoSecrets performs requests for "actions/list-repo-secrets"

List repository secrets.

  GET /repos/{owner}/{repo}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
func (c Client) ActionsListRepoSecrets(ctx context.Context, req *ActionsListRepoSecretsReq, opt ...options.Option) (*ActionsListRepoSecretsResponse, error) {
	return ActionsListRepoSecrets(ctx, req, append(c, opt...)...)
}

/*
ActionsListRepoSecretsReq is request data for Client.ActionsListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ActionsListRepoSecretsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsListRepoSecretsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListRepoSecretsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-repo-secrets",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/secrets", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRepoSecretsReq) Rel(link RelName, resp *ActionsListRepoSecretsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListRepoSecretsResponseBody is a response body for ActionsListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ActionsListRepoSecretsResponseBody struct {
	Secrets    []components.ActionsSecret `json:"secrets,omitempty"`
	TotalCount int64                      `json:"total_count,omitempty"`
}

/*
ActionsListRepoSecretsResponse is a response for ActionsListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ActionsListRepoSecretsResponse struct {
	common.Response
	request *ActionsListRepoSecretsReq
	Data    ActionsListRepoSecretsResponseBody
}

/*
ActionsListRepoWorkflows performs requests for "actions/list-repo-workflows"

List repository workflows.

  GET /repos/{owner}/{repo}/actions/workflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
func ActionsListRepoWorkflows(ctx context.Context, req *ActionsListRepoWorkflowsReq, opt ...options.Option) (*ActionsListRepoWorkflowsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListRepoWorkflowsReq)
	}
	resp := &ActionsListRepoWorkflowsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActionsListRepoWorkflowsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRepoWorkflows performs requests for "actions/list-repo-workflows"

List repository workflows.

  GET /repos/{owner}/{repo}/actions/workflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
func (c Client) ActionsListRepoWorkflows(ctx context.Context, req *ActionsListRepoWorkflowsReq, opt ...options.Option) (*ActionsListRepoWorkflowsResponse, error) {
	return ActionsListRepoWorkflows(ctx, req, append(c, opt...)...)
}

/*
ActionsListRepoWorkflowsReq is request data for Client.ActionsListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ActionsListRepoWorkflowsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsListRepoWorkflowsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListRepoWorkflowsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-repo-workflows",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/workflows", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRepoWorkflowsReq) Rel(link RelName, resp *ActionsListRepoWorkflowsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListRepoWorkflowsResponseBody is a response body for ActionsListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ActionsListRepoWorkflowsResponseBody struct {
	TotalCount int64                 `json:"total_count,omitempty"`
	Workflows  []components.Workflow `json:"workflows,omitempty"`
}

/*
ActionsListRepoWorkflowsResponse is a response for ActionsListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ActionsListRepoWorkflowsResponse struct {
	common.Response
	request *ActionsListRepoWorkflowsReq
	Data    ActionsListRepoWorkflowsResponseBody
}

/*
ActionsListRunnerApplicationsForOrg performs requests for "actions/list-runner-applications-for-org"

List runner applications for an organization.

  GET /orgs/{org}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
func ActionsListRunnerApplicationsForOrg(ctx context.Context, req *ActionsListRunnerApplicationsForOrgReq, opt ...options.Option) (*ActionsListRunnerApplicationsForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListRunnerApplicationsForOrgReq)
	}
	resp := &ActionsListRunnerApplicationsForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.RunnerApplication{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRunnerApplicationsForOrg performs requests for "actions/list-runner-applications-for-org"

List runner applications for an organization.

  GET /orgs/{org}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
func (c Client) ActionsListRunnerApplicationsForOrg(ctx context.Context, req *ActionsListRunnerApplicationsForOrgReq, opt ...options.Option) (*ActionsListRunnerApplicationsForOrgResponse, error) {
	return ActionsListRunnerApplicationsForOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsListRunnerApplicationsForOrgReq is request data for Client.ActionsListRunnerApplicationsForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
type ActionsListRunnerApplicationsForOrgReq struct {
	_url string
	Org  string
}

// HTTPRequest builds an *http.Request
func (r *ActionsListRunnerApplicationsForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListRunnerApplicationsForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-runner-applications-for-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/runners/downloads", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRunnerApplicationsForOrgReq) Rel(link RelName, resp *ActionsListRunnerApplicationsForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListRunnerApplicationsForOrgResponse is a response for ActionsListRunnerApplicationsForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
type ActionsListRunnerApplicationsForOrgResponse struct {
	common.Response
	request *ActionsListRunnerApplicationsForOrgReq
	Data    []components.RunnerApplication
}

/*
ActionsListRunnerApplicationsForRepo performs requests for "actions/list-runner-applications-for-repo"

List runner applications for a repository.

  GET /repos/{owner}/{repo}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
func ActionsListRunnerApplicationsForRepo(ctx context.Context, req *ActionsListRunnerApplicationsForRepoReq, opt ...options.Option) (*ActionsListRunnerApplicationsForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListRunnerApplicationsForRepoReq)
	}
	resp := &ActionsListRunnerApplicationsForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = []components.RunnerApplication{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRunnerApplicationsForRepo performs requests for "actions/list-runner-applications-for-repo"

List runner applications for a repository.

  GET /repos/{owner}/{repo}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
func (c Client) ActionsListRunnerApplicationsForRepo(ctx context.Context, req *ActionsListRunnerApplicationsForRepoReq, opt ...options.Option) (*ActionsListRunnerApplicationsForRepoResponse, error) {
	return ActionsListRunnerApplicationsForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsListRunnerApplicationsForRepoReq is request data for Client.ActionsListRunnerApplicationsForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
type ActionsListRunnerApplicationsForRepoReq struct {
	_url  string
	Owner string
	Repo  string
}

// HTTPRequest builds an *http.Request
func (r *ActionsListRunnerApplicationsForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListRunnerApplicationsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-runner-applications-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runners/downloads", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRunnerApplicationsForRepoReq) Rel(link RelName, resp *ActionsListRunnerApplicationsForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListRunnerApplicationsForRepoResponse is a response for ActionsListRunnerApplicationsForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
type ActionsListRunnerApplicationsForRepoResponse struct {
	common.Response
	request *ActionsListRunnerApplicationsForRepoReq
	Data    []components.RunnerApplication
}

/*
ActionsListSelectedReposForOrgSecret performs requests for "actions/list-selected-repos-for-org-secret"

List selected repositories for an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
func ActionsListSelectedReposForOrgSecret(ctx context.Context, req *ActionsListSelectedReposForOrgSecretReq, opt ...options.Option) (*ActionsListSelectedReposForOrgSecretResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListSelectedReposForOrgSecretReq)
	}
	resp := &ActionsListSelectedReposForOrgSecretResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActionsListSelectedReposForOrgSecretResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListSelectedReposForOrgSecret performs requests for "actions/list-selected-repos-for-org-secret"

List selected repositories for an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
func (c Client) ActionsListSelectedReposForOrgSecret(ctx context.Context, req *ActionsListSelectedReposForOrgSecretReq, opt ...options.Option) (*ActionsListSelectedReposForOrgSecretResponse, error) {
	return ActionsListSelectedReposForOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsListSelectedReposForOrgSecretReq is request data for Client.ActionsListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ActionsListSelectedReposForOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string
}

// HTTPRequest builds an *http.Request
func (r *ActionsListSelectedReposForOrgSecretReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListSelectedReposForOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-selected-repos-for-org-secret",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories", r.Org, r.SecretName),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListSelectedReposForOrgSecretReq) Rel(link RelName, resp *ActionsListSelectedReposForOrgSecretResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListSelectedReposForOrgSecretResponseBody is a response body for ActionsListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ActionsListSelectedReposForOrgSecretResponseBody struct {
	Repositories []components.MinimalRepository `json:"repositories,omitempty"`
	TotalCount   int64                          `json:"total_count,omitempty"`
}

/*
ActionsListSelectedReposForOrgSecretResponse is a response for ActionsListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ActionsListSelectedReposForOrgSecretResponse struct {
	common.Response
	request *ActionsListSelectedReposForOrgSecretReq
	Data    ActionsListSelectedReposForOrgSecretResponseBody
}

/*
ActionsListSelfHostedRunnersForOrg performs requests for "actions/list-self-hosted-runners-for-org"

List self-hosted runners for an organization.

  GET /orgs/{org}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
func ActionsListSelfHostedRunnersForOrg(ctx context.Context, req *ActionsListSelfHostedRunnersForOrgReq, opt ...options.Option) (*ActionsListSelfHostedRunnersForOrgResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListSelfHostedRunnersForOrgReq)
	}
	resp := &ActionsListSelfHostedRunnersForOrgResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActionsListSelfHostedRunnersForOrgResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListSelfHostedRunnersForOrg performs requests for "actions/list-self-hosted-runners-for-org"

List self-hosted runners for an organization.

  GET /orgs/{org}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
func (c Client) ActionsListSelfHostedRunnersForOrg(ctx context.Context, req *ActionsListSelfHostedRunnersForOrgReq, opt ...options.Option) (*ActionsListSelfHostedRunnersForOrgResponse, error) {
	return ActionsListSelfHostedRunnersForOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsListSelfHostedRunnersForOrgReq is request data for Client.ActionsListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ActionsListSelfHostedRunnersForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsListSelfHostedRunnersForOrgReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListSelfHostedRunnersForOrgReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-self-hosted-runners-for-org",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/runners", r.Org),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListSelfHostedRunnersForOrgReq) Rel(link RelName, resp *ActionsListSelfHostedRunnersForOrgResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListSelfHostedRunnersForOrgResponseBody is a response body for ActionsListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ActionsListSelfHostedRunnersForOrgResponseBody struct {
	Runners    []components.Runner `json:"runners,omitempty"`
	TotalCount int64               `json:"total_count,omitempty"`
}

/*
ActionsListSelfHostedRunnersForOrgResponse is a response for ActionsListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ActionsListSelfHostedRunnersForOrgResponse struct {
	common.Response
	request *ActionsListSelfHostedRunnersForOrgReq
	Data    ActionsListSelfHostedRunnersForOrgResponseBody
}

/*
ActionsListSelfHostedRunnersForRepo performs requests for "actions/list-self-hosted-runners-for-repo"

List self-hosted runners for a repository.

  GET /repos/{owner}/{repo}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
func ActionsListSelfHostedRunnersForRepo(ctx context.Context, req *ActionsListSelfHostedRunnersForRepoReq, opt ...options.Option) (*ActionsListSelfHostedRunnersForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListSelfHostedRunnersForRepoReq)
	}
	resp := &ActionsListSelfHostedRunnersForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActionsListSelfHostedRunnersForRepoResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListSelfHostedRunnersForRepo performs requests for "actions/list-self-hosted-runners-for-repo"

List self-hosted runners for a repository.

  GET /repos/{owner}/{repo}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
func (c Client) ActionsListSelfHostedRunnersForRepo(ctx context.Context, req *ActionsListSelfHostedRunnersForRepoReq, opt ...options.Option) (*ActionsListSelfHostedRunnersForRepoResponse, error) {
	return ActionsListSelfHostedRunnersForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsListSelfHostedRunnersForRepoReq is request data for Client.ActionsListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ActionsListSelfHostedRunnersForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsListSelfHostedRunnersForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListSelfHostedRunnersForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-self-hosted-runners-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runners", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListSelfHostedRunnersForRepoReq) Rel(link RelName, resp *ActionsListSelfHostedRunnersForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListSelfHostedRunnersForRepoResponseBody is a response body for ActionsListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ActionsListSelfHostedRunnersForRepoResponseBody struct {
	Runners    []components.Runner `json:"runners,omitempty"`
	TotalCount int64               `json:"total_count,omitempty"`
}

/*
ActionsListSelfHostedRunnersForRepoResponse is a response for ActionsListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ActionsListSelfHostedRunnersForRepoResponse struct {
	common.Response
	request *ActionsListSelfHostedRunnersForRepoReq
	Data    ActionsListSelfHostedRunnersForRepoResponseBody
}

/*
ActionsListWorkflowRunArtifacts performs requests for "actions/list-workflow-run-artifacts"

List workflow run artifacts.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
func ActionsListWorkflowRunArtifacts(ctx context.Context, req *ActionsListWorkflowRunArtifactsReq, opt ...options.Option) (*ActionsListWorkflowRunArtifactsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListWorkflowRunArtifactsReq)
	}
	resp := &ActionsListWorkflowRunArtifactsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActionsListWorkflowRunArtifactsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListWorkflowRunArtifacts performs requests for "actions/list-workflow-run-artifacts"

List workflow run artifacts.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
func (c Client) ActionsListWorkflowRunArtifacts(ctx context.Context, req *ActionsListWorkflowRunArtifactsReq, opt ...options.Option) (*ActionsListWorkflowRunArtifactsResponse, error) {
	return ActionsListWorkflowRunArtifacts(ctx, req, append(c, opt...)...)
}

/*
ActionsListWorkflowRunArtifactsReq is request data for Client.ActionsListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ActionsListWorkflowRunArtifactsReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsListWorkflowRunArtifactsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListWorkflowRunArtifactsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-workflow-run-artifacts",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runs/%v/artifacts", r.Owner, r.Repo, r.RunId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListWorkflowRunArtifactsReq) Rel(link RelName, resp *ActionsListWorkflowRunArtifactsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListWorkflowRunArtifactsResponseBody is a response body for ActionsListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ActionsListWorkflowRunArtifactsResponseBody struct {
	Artifacts  []components.Artifact `json:"artifacts,omitempty"`
	TotalCount int64                 `json:"total_count,omitempty"`
}

/*
ActionsListWorkflowRunArtifactsResponse is a response for ActionsListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ActionsListWorkflowRunArtifactsResponse struct {
	common.Response
	request *ActionsListWorkflowRunArtifactsReq
	Data    ActionsListWorkflowRunArtifactsResponseBody
}

/*
ActionsListWorkflowRuns performs requests for "actions/list-workflow-runs"

List workflow runs.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
func ActionsListWorkflowRuns(ctx context.Context, req *ActionsListWorkflowRunsReq, opt ...options.Option) (*ActionsListWorkflowRunsResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListWorkflowRunsReq)
	}
	resp := &ActionsListWorkflowRunsResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActionsListWorkflowRunsResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListWorkflowRuns performs requests for "actions/list-workflow-runs"

List workflow runs.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
func (c Client) ActionsListWorkflowRuns(ctx context.Context, req *ActionsListWorkflowRunsReq, opt ...options.Option) (*ActionsListWorkflowRunsResponse, error) {
	return ActionsListWorkflowRuns(ctx, req, append(c, opt...)...)
}

/*
ActionsListWorkflowRunsReq is request data for Client.ActionsListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ActionsListWorkflowRunsReq struct {
	_url       string
	Owner      string
	Repo       string
	WorkflowId int64

	/*
	Returns someone's workflow runs. Use the login for the user who created the
	`push` associated with the check suite or workflow run.
	*/
	Actor *string

	/*
	Returns workflow runs associated with a branch. Use the name of the branch of
	the `push`.
	*/
	Branch *string

	/*
	Returns workflow run triggered by the event you specify. For example, `push`,
	`pull_request` or `issue`. For more information, see "[Events that trigger
	workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
	*/
	Event *string

	/*
	Returns workflow runs associated with the check run `status` or `conclusion` you
	specify. For example, a conclusion can be `success` or a status can be
	`completed`. For more information, see the `status` and `conclusion` options
	available in "[Create a check
	run](https://developer.github.com/v3/checks/runs/#create-a-check-run)."
	*/
	Status *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsListWorkflowRunsReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListWorkflowRunsReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Actor != nil {
		query.Set("actor", *r.Actor)
	}
	if r.Branch != nil {
		query.Set("branch", *r.Branch)
	}
	if r.Event != nil {
		query.Set("event", *r.Event)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-workflow-runs",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/workflows/%v/runs", r.Owner, r.Repo, r.WorkflowId),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListWorkflowRunsReq) Rel(link RelName, resp *ActionsListWorkflowRunsResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListWorkflowRunsResponseBody is a response body for ActionsListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ActionsListWorkflowRunsResponseBody struct {
	TotalCount   int64                    `json:"total_count,omitempty"`
	WorkflowRuns []components.WorkflowRun `json:"workflow_runs,omitempty"`
}

/*
ActionsListWorkflowRunsResponse is a response for ActionsListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ActionsListWorkflowRunsResponse struct {
	common.Response
	request *ActionsListWorkflowRunsReq
	Data    ActionsListWorkflowRunsResponseBody
}

/*
ActionsListWorkflowRunsForRepo performs requests for "actions/list-workflow-runs-for-repo"

List workflow runs for a repository.

  GET /repos/{owner}/{repo}/actions/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
func ActionsListWorkflowRunsForRepo(ctx context.Context, req *ActionsListWorkflowRunsForRepoReq, opt ...options.Option) (*ActionsListWorkflowRunsForRepoResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsListWorkflowRunsForRepoReq)
	}
	resp := &ActionsListWorkflowRunsForRepoResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	resp.Data = ActionsListWorkflowRunsForRepoResponseBody{}
	err = internal.DecodeResponseBody(r, builder, opts, &resp.Data)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListWorkflowRunsForRepo performs requests for "actions/list-workflow-runs-for-repo"

List workflow runs for a repository.

  GET /repos/{owner}/{repo}/actions/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
func (c Client) ActionsListWorkflowRunsForRepo(ctx context.Context, req *ActionsListWorkflowRunsForRepoReq, opt ...options.Option) (*ActionsListWorkflowRunsForRepoResponse, error) {
	return ActionsListWorkflowRunsForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsListWorkflowRunsForRepoReq is request data for Client.ActionsListWorkflowRunsForRepo

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
type ActionsListWorkflowRunsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Returns someone's workflow runs. Use the login for the user who created the
	`push` associated with the check suite or workflow run.
	*/
	Actor *string

	/*
	Returns workflow runs associated with a branch. Use the name of the branch of
	the `push`.
	*/
	Branch *string

	/*
	Returns workflow run triggered by the event you specify. For example, `push`,
	`pull_request` or `issue`. For more information, see "[Events that trigger
	workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
	*/
	Event *string

	/*
	Returns workflow runs associated with the check run `status` or `conclusion` you
	specify. For example, a conclusion can be `success` or a status can be
	`completed`. For more information, see the `status` and `conclusion` options
	available in "[Create a check
	run](https://developer.github.com/v3/checks/runs/#create-a-check-run)."
	*/
	Status *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsListWorkflowRunsForRepoReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsListWorkflowRunsForRepoReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}
	if r.Actor != nil {
		query.Set("actor", *r.Actor)
	}
	if r.Branch != nil {
		query.Set("branch", *r.Branch)
	}
	if r.Event != nil {
		query.Set("event", *r.Event)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{200},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"accept": String("application/json")},
		Method:           "GET",
		OperationID:      "actions/list-workflow-runs-for-repo",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runs", r.Owner, r.Repo),
		URLQuery:         query,
		ValidStatuses:    []int{200},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListWorkflowRunsForRepoReq) Rel(link RelName, resp *ActionsListWorkflowRunsForRepoResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListWorkflowRunsForRepoResponseBody is a response body for ActionsListWorkflowRunsForRepo

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
type ActionsListWorkflowRunsForRepoResponseBody struct {
	TotalCount   int64                    `json:"total_count,omitempty"`
	WorkflowRuns []components.WorkflowRun `json:"workflow_runs,omitempty"`
}

/*
ActionsListWorkflowRunsForRepoResponse is a response for ActionsListWorkflowRunsForRepo

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
type ActionsListWorkflowRunsForRepoResponse struct {
	common.Response
	request *ActionsListWorkflowRunsForRepoReq
	Data    ActionsListWorkflowRunsForRepoResponseBody
}

/*
ActionsReRunWorkflow performs requests for "actions/re-run-workflow"

Re-run a workflow.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
func ActionsReRunWorkflow(ctx context.Context, req *ActionsReRunWorkflowReq, opt ...options.Option) (*ActionsReRunWorkflowResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsReRunWorkflowReq)
	}
	resp := &ActionsReRunWorkflowResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsReRunWorkflow performs requests for "actions/re-run-workflow"

Re-run a workflow.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
func (c Client) ActionsReRunWorkflow(ctx context.Context, req *ActionsReRunWorkflowReq, opt ...options.Option) (*ActionsReRunWorkflowResponse, error) {
	return ActionsReRunWorkflow(ctx, req, append(c, opt...)...)
}

/*
ActionsReRunWorkflowReq is request data for Client.ActionsReRunWorkflow

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
type ActionsReRunWorkflowReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsReRunWorkflowReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsReRunWorkflowReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "POST",
		OperationID:      "actions/re-run-workflow",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/repos/%v/%v/actions/runs/%v/rerun", r.Owner, r.Repo, r.RunId),
		URLQuery:         query,
		ValidStatuses:    []int{201},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsReRunWorkflowReq) Rel(link RelName, resp *ActionsReRunWorkflowResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsReRunWorkflowResponse is a response for ActionsReRunWorkflow

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
type ActionsReRunWorkflowResponse struct {
	common.Response
	request *ActionsReRunWorkflowReq
}

/*
ActionsRemoveSelectedRepoFromOrgSecret performs requests for "actions/remove-selected-repo-from-org-secret"

Remove selected repository from an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
func ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, req *ActionsRemoveSelectedRepoFromOrgSecretReq, opt ...options.Option) (*ActionsRemoveSelectedRepoFromOrgSecretResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsRemoveSelectedRepoFromOrgSecretReq)
	}
	resp := &ActionsRemoveSelectedRepoFromOrgSecretResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsRemoveSelectedRepoFromOrgSecret performs requests for "actions/remove-selected-repo-from-org-secret"

Remove selected repository from an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
func (c Client) ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, req *ActionsRemoveSelectedRepoFromOrgSecretReq, opt ...options.Option) (*ActionsRemoveSelectedRepoFromOrgSecretResponse, error) {
	return ActionsRemoveSelectedRepoFromOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsRemoveSelectedRepoFromOrgSecretReq is request data for Client.ActionsRemoveSelectedRepoFromOrgSecret

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
type ActionsRemoveSelectedRepoFromOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string

	// repository_id parameter
	RepositoryId int64
}

// HTTPRequest builds an *http.Request
func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             nil,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{},
		Method:           "DELETE",
		OperationID:      "actions/remove-selected-repo-from-org-secret",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories/%v", r.Org, r.SecretName, r.RepositoryId),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) Rel(link RelName, resp *ActionsRemoveSelectedRepoFromOrgSecretResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsRemoveSelectedRepoFromOrgSecretResponse is a response for ActionsRemoveSelectedRepoFromOrgSecret

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
type ActionsRemoveSelectedRepoFromOrgSecretResponse struct {
	common.Response
	request *ActionsRemoveSelectedRepoFromOrgSecretReq
}

/*
ActionsSetSelectedReposForOrgSecret performs requests for "actions/set-selected-repos-for-org-secret"

Set selected repositories for an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
func ActionsSetSelectedReposForOrgSecret(ctx context.Context, req *ActionsSetSelectedReposForOrgSecretReq, opt ...options.Option) (*ActionsSetSelectedReposForOrgSecretResponse, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	if req == nil {
		req = new(ActionsSetSelectedReposForOrgSecretReq)
	}
	resp := &ActionsSetSelectedReposForOrgSecretResponse{request: req}
	builder := req.requestBuilder()
	r, err := internal.DoRequest(ctx, builder, opts)

	if r != nil {
		resp.Response = *r
	}
	if err != nil {
		return resp, err
	}

	err = internal.DecodeResponseBody(r, builder, opts, nil)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsSetSelectedReposForOrgSecret performs requests for "actions/set-selected-repos-for-org-secret"

Set selected repositories for an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
func (c Client) ActionsSetSelectedReposForOrgSecret(ctx context.Context, req *ActionsSetSelectedReposForOrgSecretReq, opt ...options.Option) (*ActionsSetSelectedReposForOrgSecretResponse, error) {
	return ActionsSetSelectedReposForOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsSetSelectedReposForOrgSecretReq is request data for Client.ActionsSetSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type ActionsSetSelectedReposForOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName  string
	RequestBody ActionsSetSelectedReposForOrgSecretReqBody
}

// HTTPRequest builds an *http.Request
func (r *ActionsSetSelectedReposForOrgSecretReq) HTTPRequest(ctx context.Context, opt ...options.Option) (*http.Request, error) {
	opts, err := options.BuildOptions(opt...)
	if err != nil {
		return nil, err
	}
	return r.requestBuilder().HTTPRequest(ctx, opts)
}

func (r *ActionsSetSelectedReposForOrgSecretReq) requestBuilder() *internal.RequestBuilder {
	query := url.Values{}

	builder := &internal.RequestBuilder{
		AllPreviews:      []string{},
		Body:             r.RequestBody,
		DataStatuses:     []int{},
		ExplicitURL:      r._url,
		HeaderVals:       map[string]*string{"content-type": String("application/json")},
		Method:           "PUT",
		OperationID:      "actions/set-selected-repos-for-org-secret",
		Previews:         map[string]bool{},
		RequiredPreviews: []string{},
		URLPath:          fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories", r.Org, r.SecretName),
		URLQuery:         query,
		ValidStatuses:    []int{204},
	}
	return builder
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsSetSelectedReposForOrgSecretReq) Rel(link RelName, resp *ActionsSetSelectedReposForOrgSecretResponse) bool {
	u := resp.RelLink(string(link))
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsSetSelectedReposForOrgSecretReqBody is a request body for actions/set-selected-repos-for-org-secret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type ActionsSetSelectedReposForOrgSecretReqBody struct {

	/*
	An array of repository ids that can access the organization secret. You can only
	provide a list of repository ids when the `visibility` is set to `selected`. You
	can add and remove individual repositories using the [Set selected repositories
	for an organization
	secret](https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret)
	and [Remove selected repository from an organization
	secret](https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret)
	endpoints.
	*/
	SelectedRepositoryIds []int64 `json:"selected_repository_ids,omitempty"`
}

/*
ActionsSetSelectedReposForOrgSecretResponse is a response for ActionsSetSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type ActionsSetSelectedReposForOrgSecretResponse struct {
	common.Response
	request *ActionsSetSelectedReposForOrgSecretReq
}
