// Code generated by octo-go; DO NOT EDIT.

package octo

import (
	"context"
	"fmt"
	components "github.com/willabides/octo-go/components"
	"net/http"
	"net/url"
	"strconv"
)

/*
ActionsAddSelectedRepoToOrgSecret performs requests for "actions/add-selected-repo-to-org-secret"

Add selected repository to an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
func ActionsAddSelectedRepoToOrgSecret(ctx context.Context, req *ActionsAddSelectedRepoToOrgSecretReq, opt ...RequestOption) (*ActionsAddSelectedRepoToOrgSecretResponse, error) {
	if req == nil {
		req = new(ActionsAddSelectedRepoToOrgSecretReq)
	}
	resp := &ActionsAddSelectedRepoToOrgSecretResponse{request: req}
	r, err := doRequest(ctx, req, "actions/add-selected-repo-to-org-secret", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/add-selected-repo-to-org-secret")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsAddSelectedRepoToOrgSecret performs requests for "actions/add-selected-repo-to-org-secret"

Add selected repository to an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
func (c Client) ActionsAddSelectedRepoToOrgSecret(ctx context.Context, req *ActionsAddSelectedRepoToOrgSecretReq, opt ...RequestOption) (*ActionsAddSelectedRepoToOrgSecretResponse, error) {
	return ActionsAddSelectedRepoToOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsAddSelectedRepoToOrgSecretReq is request data for Client.ActionsAddSelectedRepoToOrgSecret

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
type ActionsAddSelectedRepoToOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string

	// repository_id parameter
	RepositoryId int64
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) url() string {
	return r._url
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories/%v", r.Org, r.SecretName, r.RepositoryId)
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) method() string {
	return "PUT"
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) body() interface{} {
	return nil
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsAddSelectedRepoToOrgSecretReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsAddSelectedRepoToOrgSecretReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/add-selected-repo-to-org-secret", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsAddSelectedRepoToOrgSecretReq) Rel(link RelName, resp *ActionsAddSelectedRepoToOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsAddSelectedRepoToOrgSecretResponse is a response for ActionsAddSelectedRepoToOrgSecret

https://developer.github.com/v3/actions/secrets/#add-selected-repository-to-an-organization-secret
*/
type ActionsAddSelectedRepoToOrgSecretResponse struct {
	response
	request *ActionsAddSelectedRepoToOrgSecretReq
}

/*
ActionsCancelWorkflowRun performs requests for "actions/cancel-workflow-run"

Cancel a workflow run.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
func ActionsCancelWorkflowRun(ctx context.Context, req *ActionsCancelWorkflowRunReq, opt ...RequestOption) (*ActionsCancelWorkflowRunResponse, error) {
	if req == nil {
		req = new(ActionsCancelWorkflowRunReq)
	}
	resp := &ActionsCancelWorkflowRunResponse{request: req}
	r, err := doRequest(ctx, req, "actions/cancel-workflow-run", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/cancel-workflow-run")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCancelWorkflowRun performs requests for "actions/cancel-workflow-run"

Cancel a workflow run.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
func (c Client) ActionsCancelWorkflowRun(ctx context.Context, req *ActionsCancelWorkflowRunReq, opt ...RequestOption) (*ActionsCancelWorkflowRunResponse, error) {
	return ActionsCancelWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsCancelWorkflowRunReq is request data for Client.ActionsCancelWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
type ActionsCancelWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsCancelWorkflowRunReq) url() string {
	return r._url
}

func (r *ActionsCancelWorkflowRunReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/cancel", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsCancelWorkflowRunReq) method() string {
	return "POST"
}

func (r *ActionsCancelWorkflowRunReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCancelWorkflowRunReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCancelWorkflowRunReq) body() interface{} {
	return nil
}

func (r *ActionsCancelWorkflowRunReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsCancelWorkflowRunReq) validStatuses() []int {
	return []int{202}
}

// HTTPRequest builds an *http.Request
func (r *ActionsCancelWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/cancel-workflow-run", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCancelWorkflowRunReq) Rel(link RelName, resp *ActionsCancelWorkflowRunResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCancelWorkflowRunResponse is a response for ActionsCancelWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#cancel-a-workflow-run
*/
type ActionsCancelWorkflowRunResponse struct {
	response
	request *ActionsCancelWorkflowRunReq
}

/*
ActionsCreateOrUpdateOrgSecret performs requests for "actions/create-or-update-org-secret"

Create or update an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
func ActionsCreateOrUpdateOrgSecret(ctx context.Context, req *ActionsCreateOrUpdateOrgSecretReq, opt ...RequestOption) (*ActionsCreateOrUpdateOrgSecretResponse, error) {
	if req == nil {
		req = new(ActionsCreateOrUpdateOrgSecretReq)
	}
	resp := &ActionsCreateOrUpdateOrgSecretResponse{request: req}
	r, err := doRequest(ctx, req, "actions/create-or-update-org-secret", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/create-or-update-org-secret")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateOrUpdateOrgSecret performs requests for "actions/create-or-update-org-secret"

Create or update an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
func (c Client) ActionsCreateOrUpdateOrgSecret(ctx context.Context, req *ActionsCreateOrUpdateOrgSecretReq, opt ...RequestOption) (*ActionsCreateOrUpdateOrgSecretResponse, error) {
	return ActionsCreateOrUpdateOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateOrUpdateOrgSecretReq is request data for Client.ActionsCreateOrUpdateOrgSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type ActionsCreateOrUpdateOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName  string
	RequestBody ActionsCreateOrUpdateOrgSecretReqBody
}

func (r *ActionsCreateOrUpdateOrgSecretReq) url() string {
	return r._url
}

func (r *ActionsCreateOrUpdateOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName)
}

func (r *ActionsCreateOrUpdateOrgSecretReq) method() string {
	return "PUT"
}

func (r *ActionsCreateOrUpdateOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateOrUpdateOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"content-type": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateOrUpdateOrgSecretReq) body() interface{} {
	return r.RequestBody
}

func (r *ActionsCreateOrUpdateOrgSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsCreateOrUpdateOrgSecretReq) validStatuses() []int {
	return []int{201, 204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateOrUpdateOrgSecretReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/create-or-update-org-secret", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateOrUpdateOrgSecretReq) Rel(link RelName, resp *ActionsCreateOrUpdateOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateOrUpdateOrgSecretReqBody is a request body for actions/create-or-update-org-secret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type ActionsCreateOrUpdateOrgSecretReqBody struct {

	/*
	Value for your secret, encrypted with
	[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using
	the public key retrieved from the [Get an organization public
	key](https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key)
	endpoint.
	*/
	EncryptedValue *string `json:"encrypted_value,omitempty"`

	// ID of the key you used to encrypt the secret.
	KeyId *string `json:"key_id,omitempty"`

	/*
	An array of repository ids that can access the organization secret. You can only
	provide a list of repository ids when the `visibility` is set to `selected`. You
	can manage the list of selected repositories using the [List selected
	repositories for an organization
	secret](https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret),
	[Set selected repositories for an organization
	secret](https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret),
	and [Remove selected repository from an organization
	secret](https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret)
	endpoints.
	*/
	SelectedRepositoryIds []string `json:"selected_repository_ids,omitempty"`

	/*
	Configures the access that repositories have to the organization secret. Can be
	one of:
	\- `all` - All repositories in an organization can access the secret.
	\- `private` - Private repositories in an organization can access the secret.
	\- `selected` - Only specific repositories can access the secret.
	*/
	Visibility *string `json:"visibility,omitempty"`
}

/*
ActionsCreateOrUpdateOrgSecretResponse is a response for ActionsCreateOrUpdateOrgSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-an-organization-secret
*/
type ActionsCreateOrUpdateOrgSecretResponse struct {
	response
	request *ActionsCreateOrUpdateOrgSecretReq
}

/*
ActionsCreateOrUpdateRepoSecret performs requests for "actions/create-or-update-repo-secret"

Create or update a repository secret.

  PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
func ActionsCreateOrUpdateRepoSecret(ctx context.Context, req *ActionsCreateOrUpdateRepoSecretReq, opt ...RequestOption) (*ActionsCreateOrUpdateRepoSecretResponse, error) {
	if req == nil {
		req = new(ActionsCreateOrUpdateRepoSecretReq)
	}
	resp := &ActionsCreateOrUpdateRepoSecretResponse{request: req}
	r, err := doRequest(ctx, req, "actions/create-or-update-repo-secret", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/create-or-update-repo-secret")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateOrUpdateRepoSecret performs requests for "actions/create-or-update-repo-secret"

Create or update a repository secret.

  PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
func (c Client) ActionsCreateOrUpdateRepoSecret(ctx context.Context, req *ActionsCreateOrUpdateRepoSecretReq, opt ...RequestOption) (*ActionsCreateOrUpdateRepoSecretResponse, error) {
	return ActionsCreateOrUpdateRepoSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateOrUpdateRepoSecretReq is request data for Client.ActionsCreateOrUpdateRepoSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type ActionsCreateOrUpdateRepoSecretReq struct {
	_url  string
	Owner string
	Repo  string

	// secret_name parameter
	SecretName  string
	RequestBody ActionsCreateOrUpdateRepoSecretReqBody
}

func (r *ActionsCreateOrUpdateRepoSecretReq) url() string {
	return r._url
}

func (r *ActionsCreateOrUpdateRepoSecretReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName)
}

func (r *ActionsCreateOrUpdateRepoSecretReq) method() string {
	return "PUT"
}

func (r *ActionsCreateOrUpdateRepoSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateOrUpdateRepoSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"content-type": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateOrUpdateRepoSecretReq) body() interface{} {
	return r.RequestBody
}

func (r *ActionsCreateOrUpdateRepoSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsCreateOrUpdateRepoSecretReq) validStatuses() []int {
	return []int{201, 204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateOrUpdateRepoSecretReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/create-or-update-repo-secret", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateOrUpdateRepoSecretReq) Rel(link RelName, resp *ActionsCreateOrUpdateRepoSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateOrUpdateRepoSecretReqBody is a request body for actions/create-or-update-repo-secret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type ActionsCreateOrUpdateRepoSecretReqBody struct {

	/*
	Value for your secret, encrypted with
	[LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using
	the public key retrieved from the [Get a repository public
	key](https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key)
	endpoint.
	*/
	EncryptedValue *string `json:"encrypted_value,omitempty"`

	// ID of the key you used to encrypt the secret.
	KeyId *string `json:"key_id,omitempty"`
}

/*
ActionsCreateOrUpdateRepoSecretResponse is a response for ActionsCreateOrUpdateRepoSecret

https://developer.github.com/v3/actions/secrets/#create-or-update-a-repository-secret
*/
type ActionsCreateOrUpdateRepoSecretResponse struct {
	response
	request *ActionsCreateOrUpdateRepoSecretReq
}

/*
ActionsCreateRegistrationTokenForOrg performs requests for "actions/create-registration-token-for-org"

Create a registration token for an organization.

  POST /orgs/{org}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
func ActionsCreateRegistrationTokenForOrg(ctx context.Context, req *ActionsCreateRegistrationTokenForOrgReq, opt ...RequestOption) (*ActionsCreateRegistrationTokenForOrgResponse, error) {
	if req == nil {
		req = new(ActionsCreateRegistrationTokenForOrgReq)
	}
	resp := &ActionsCreateRegistrationTokenForOrgResponse{request: req}
	r, err := doRequest(ctx, req, "actions/create-registration-token-for-org", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.AuthenticationToken{}
	err = r.decodeBody(&resp.Data, "actions/create-registration-token-for-org")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRegistrationTokenForOrg performs requests for "actions/create-registration-token-for-org"

Create a registration token for an organization.

  POST /orgs/{org}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
func (c Client) ActionsCreateRegistrationTokenForOrg(ctx context.Context, req *ActionsCreateRegistrationTokenForOrgReq, opt ...RequestOption) (*ActionsCreateRegistrationTokenForOrgResponse, error) {
	return ActionsCreateRegistrationTokenForOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateRegistrationTokenForOrgReq is request data for Client.ActionsCreateRegistrationTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
type ActionsCreateRegistrationTokenForOrgReq struct {
	_url string
	Org  string
}

func (r *ActionsCreateRegistrationTokenForOrgReq) url() string {
	return r._url
}

func (r *ActionsCreateRegistrationTokenForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners/registration-token", r.Org)
}

func (r *ActionsCreateRegistrationTokenForOrgReq) method() string {
	return "POST"
}

func (r *ActionsCreateRegistrationTokenForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateRegistrationTokenForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateRegistrationTokenForOrgReq) body() interface{} {
	return nil
}

func (r *ActionsCreateRegistrationTokenForOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRegistrationTokenForOrgReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateRegistrationTokenForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/create-registration-token-for-org", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRegistrationTokenForOrgReq) Rel(link RelName, resp *ActionsCreateRegistrationTokenForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateRegistrationTokenForOrgResponse is a response for ActionsCreateRegistrationTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-an-organization
*/
type ActionsCreateRegistrationTokenForOrgResponse struct {
	response
	request *ActionsCreateRegistrationTokenForOrgReq
	Data    components.AuthenticationToken
}

/*
ActionsCreateRegistrationTokenForRepo performs requests for "actions/create-registration-token-for-repo"

Create a registration token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
func ActionsCreateRegistrationTokenForRepo(ctx context.Context, req *ActionsCreateRegistrationTokenForRepoReq, opt ...RequestOption) (*ActionsCreateRegistrationTokenForRepoResponse, error) {
	if req == nil {
		req = new(ActionsCreateRegistrationTokenForRepoReq)
	}
	resp := &ActionsCreateRegistrationTokenForRepoResponse{request: req}
	r, err := doRequest(ctx, req, "actions/create-registration-token-for-repo", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.AuthenticationToken{}
	err = r.decodeBody(&resp.Data, "actions/create-registration-token-for-repo")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRegistrationTokenForRepo performs requests for "actions/create-registration-token-for-repo"

Create a registration token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/registration-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
func (c Client) ActionsCreateRegistrationTokenForRepo(ctx context.Context, req *ActionsCreateRegistrationTokenForRepoReq, opt ...RequestOption) (*ActionsCreateRegistrationTokenForRepoResponse, error) {
	return ActionsCreateRegistrationTokenForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateRegistrationTokenForRepoReq is request data for Client.ActionsCreateRegistrationTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
type ActionsCreateRegistrationTokenForRepoReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ActionsCreateRegistrationTokenForRepoReq) url() string {
	return r._url
}

func (r *ActionsCreateRegistrationTokenForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners/registration-token", r.Owner, r.Repo)
}

func (r *ActionsCreateRegistrationTokenForRepoReq) method() string {
	return "POST"
}

func (r *ActionsCreateRegistrationTokenForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateRegistrationTokenForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateRegistrationTokenForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsCreateRegistrationTokenForRepoReq) dataStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRegistrationTokenForRepoReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateRegistrationTokenForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/create-registration-token-for-repo", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRegistrationTokenForRepoReq) Rel(link RelName, resp *ActionsCreateRegistrationTokenForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateRegistrationTokenForRepoResponse is a response for ActionsCreateRegistrationTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-registration-token-for-a-repository
*/
type ActionsCreateRegistrationTokenForRepoResponse struct {
	response
	request *ActionsCreateRegistrationTokenForRepoReq
	Data    components.AuthenticationToken
}

/*
ActionsCreateRemoveTokenForOrg performs requests for "actions/create-remove-token-for-org"

Create a remove token for an organization.

  POST /orgs/{org}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
func ActionsCreateRemoveTokenForOrg(ctx context.Context, req *ActionsCreateRemoveTokenForOrgReq, opt ...RequestOption) (*ActionsCreateRemoveTokenForOrgResponse, error) {
	if req == nil {
		req = new(ActionsCreateRemoveTokenForOrgReq)
	}
	resp := &ActionsCreateRemoveTokenForOrgResponse{request: req}
	r, err := doRequest(ctx, req, "actions/create-remove-token-for-org", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.AuthenticationToken{}
	err = r.decodeBody(&resp.Data, "actions/create-remove-token-for-org")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRemoveTokenForOrg performs requests for "actions/create-remove-token-for-org"

Create a remove token for an organization.

  POST /orgs/{org}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
func (c Client) ActionsCreateRemoveTokenForOrg(ctx context.Context, req *ActionsCreateRemoveTokenForOrgReq, opt ...RequestOption) (*ActionsCreateRemoveTokenForOrgResponse, error) {
	return ActionsCreateRemoveTokenForOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateRemoveTokenForOrgReq is request data for Client.ActionsCreateRemoveTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
type ActionsCreateRemoveTokenForOrgReq struct {
	_url string
	Org  string
}

func (r *ActionsCreateRemoveTokenForOrgReq) url() string {
	return r._url
}

func (r *ActionsCreateRemoveTokenForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners/remove-token", r.Org)
}

func (r *ActionsCreateRemoveTokenForOrgReq) method() string {
	return "POST"
}

func (r *ActionsCreateRemoveTokenForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateRemoveTokenForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateRemoveTokenForOrgReq) body() interface{} {
	return nil
}

func (r *ActionsCreateRemoveTokenForOrgReq) dataStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRemoveTokenForOrgReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateRemoveTokenForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/create-remove-token-for-org", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRemoveTokenForOrgReq) Rel(link RelName, resp *ActionsCreateRemoveTokenForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateRemoveTokenForOrgResponse is a response for ActionsCreateRemoveTokenForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-an-organization
*/
type ActionsCreateRemoveTokenForOrgResponse struct {
	response
	request *ActionsCreateRemoveTokenForOrgReq
	Data    components.AuthenticationToken
}

/*
ActionsCreateRemoveTokenForRepo performs requests for "actions/create-remove-token-for-repo"

Create a remove token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
func ActionsCreateRemoveTokenForRepo(ctx context.Context, req *ActionsCreateRemoveTokenForRepoReq, opt ...RequestOption) (*ActionsCreateRemoveTokenForRepoResponse, error) {
	if req == nil {
		req = new(ActionsCreateRemoveTokenForRepoReq)
	}
	resp := &ActionsCreateRemoveTokenForRepoResponse{request: req}
	r, err := doRequest(ctx, req, "actions/create-remove-token-for-repo", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.AuthenticationToken{}
	err = r.decodeBody(&resp.Data, "actions/create-remove-token-for-repo")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateRemoveTokenForRepo performs requests for "actions/create-remove-token-for-repo"

Create a remove token for a repository.

  POST /repos/{owner}/{repo}/actions/runners/remove-token

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
func (c Client) ActionsCreateRemoveTokenForRepo(ctx context.Context, req *ActionsCreateRemoveTokenForRepoReq, opt ...RequestOption) (*ActionsCreateRemoveTokenForRepoResponse, error) {
	return ActionsCreateRemoveTokenForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateRemoveTokenForRepoReq is request data for Client.ActionsCreateRemoveTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
type ActionsCreateRemoveTokenForRepoReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ActionsCreateRemoveTokenForRepoReq) url() string {
	return r._url
}

func (r *ActionsCreateRemoveTokenForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners/remove-token", r.Owner, r.Repo)
}

func (r *ActionsCreateRemoveTokenForRepoReq) method() string {
	return "POST"
}

func (r *ActionsCreateRemoveTokenForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateRemoveTokenForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateRemoveTokenForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsCreateRemoveTokenForRepoReq) dataStatuses() []int {
	return []int{201}
}

func (r *ActionsCreateRemoveTokenForRepoReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateRemoveTokenForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/create-remove-token-for-repo", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateRemoveTokenForRepoReq) Rel(link RelName, resp *ActionsCreateRemoveTokenForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateRemoveTokenForRepoResponse is a response for ActionsCreateRemoveTokenForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#create-a-remove-token-for-a-repository
*/
type ActionsCreateRemoveTokenForRepoResponse struct {
	response
	request *ActionsCreateRemoveTokenForRepoReq
	Data    components.AuthenticationToken
}

/*
ActionsCreateWorkflowDispatch performs requests for "actions/create-workflow-dispatch"

Create a workflow dispatch event.

  POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
func ActionsCreateWorkflowDispatch(ctx context.Context, req *ActionsCreateWorkflowDispatchReq, opt ...RequestOption) (*ActionsCreateWorkflowDispatchResponse, error) {
	if req == nil {
		req = new(ActionsCreateWorkflowDispatchReq)
	}
	resp := &ActionsCreateWorkflowDispatchResponse{request: req}
	r, err := doRequest(ctx, req, "actions/create-workflow-dispatch", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/create-workflow-dispatch")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsCreateWorkflowDispatch performs requests for "actions/create-workflow-dispatch"

Create a workflow dispatch event.

  POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
func (c Client) ActionsCreateWorkflowDispatch(ctx context.Context, req *ActionsCreateWorkflowDispatchReq, opt ...RequestOption) (*ActionsCreateWorkflowDispatchResponse, error) {
	return ActionsCreateWorkflowDispatch(ctx, req, append(c, opt...)...)
}

/*
ActionsCreateWorkflowDispatchReq is request data for Client.ActionsCreateWorkflowDispatch

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
type ActionsCreateWorkflowDispatchReq struct {
	_url        string
	Owner       string
	Repo        string
	WorkflowId  int64
	RequestBody ActionsCreateWorkflowDispatchReqBody
}

func (r *ActionsCreateWorkflowDispatchReq) url() string {
	return r._url
}

func (r *ActionsCreateWorkflowDispatchReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/workflows/%v/dispatches", r.Owner, r.Repo, r.WorkflowId)
}

func (r *ActionsCreateWorkflowDispatchReq) method() string {
	return "POST"
}

func (r *ActionsCreateWorkflowDispatchReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsCreateWorkflowDispatchReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"content-type": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsCreateWorkflowDispatchReq) body() interface{} {
	return r.RequestBody
}

func (r *ActionsCreateWorkflowDispatchReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsCreateWorkflowDispatchReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsCreateWorkflowDispatchReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/create-workflow-dispatch", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsCreateWorkflowDispatchReq) Rel(link RelName, resp *ActionsCreateWorkflowDispatchResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsCreateWorkflowDispatchReqBody is a request body for actions/create-workflow-dispatch

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
type ActionsCreateWorkflowDispatchReqBody struct {

	/*
	Input keys and values configured in the workflow file. The maximum number of
	properties is 10. Any default properties configured in the workflow file will be
	used when `inputs` are omitted.
	*/
	Inputs map[string]string `json:"inputs,omitempty"`

	// The reference of the workflow run. The reference can be a branch, tag, or a commit SHA.
	Ref *string `json:"ref"`
}

/*
ActionsCreateWorkflowDispatchResponse is a response for ActionsCreateWorkflowDispatch

https://developer.github.com/v3/actions/workflows/#create-a-workflow-dispatch-event
*/
type ActionsCreateWorkflowDispatchResponse struct {
	response
	request *ActionsCreateWorkflowDispatchReq
}

/*
ActionsDeleteArtifact performs requests for "actions/delete-artifact"

Delete an artifact.

  DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
func ActionsDeleteArtifact(ctx context.Context, req *ActionsDeleteArtifactReq, opt ...RequestOption) (*ActionsDeleteArtifactResponse, error) {
	if req == nil {
		req = new(ActionsDeleteArtifactReq)
	}
	resp := &ActionsDeleteArtifactResponse{request: req}
	r, err := doRequest(ctx, req, "actions/delete-artifact", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/delete-artifact")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteArtifact performs requests for "actions/delete-artifact"

Delete an artifact.

  DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
func (c Client) ActionsDeleteArtifact(ctx context.Context, req *ActionsDeleteArtifactReq, opt ...RequestOption) (*ActionsDeleteArtifactResponse, error) {
	return ActionsDeleteArtifact(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteArtifactReq is request data for Client.ActionsDeleteArtifact

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
type ActionsDeleteArtifactReq struct {
	_url  string
	Owner string
	Repo  string

	// artifact_id parameter
	ArtifactId int64
}

func (r *ActionsDeleteArtifactReq) url() string {
	return r._url
}

func (r *ActionsDeleteArtifactReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v", r.Owner, r.Repo, r.ArtifactId)
}

func (r *ActionsDeleteArtifactReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteArtifactReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteArtifactReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteArtifactReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteArtifactReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteArtifactReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteArtifactReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/delete-artifact", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteArtifactReq) Rel(link RelName, resp *ActionsDeleteArtifactResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteArtifactResponse is a response for ActionsDeleteArtifact

https://developer.github.com/v3/actions/artifacts/#delete-an-artifact
*/
type ActionsDeleteArtifactResponse struct {
	response
	request *ActionsDeleteArtifactReq
}

/*
ActionsDeleteOrgSecret performs requests for "actions/delete-org-secret"

Delete an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
func ActionsDeleteOrgSecret(ctx context.Context, req *ActionsDeleteOrgSecretReq, opt ...RequestOption) (*ActionsDeleteOrgSecretResponse, error) {
	if req == nil {
		req = new(ActionsDeleteOrgSecretReq)
	}
	resp := &ActionsDeleteOrgSecretResponse{request: req}
	r, err := doRequest(ctx, req, "actions/delete-org-secret", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/delete-org-secret")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteOrgSecret performs requests for "actions/delete-org-secret"

Delete an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
func (c Client) ActionsDeleteOrgSecret(ctx context.Context, req *ActionsDeleteOrgSecretReq, opt ...RequestOption) (*ActionsDeleteOrgSecretResponse, error) {
	return ActionsDeleteOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteOrgSecretReq is request data for Client.ActionsDeleteOrgSecret

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
type ActionsDeleteOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string
}

func (r *ActionsDeleteOrgSecretReq) url() string {
	return r._url
}

func (r *ActionsDeleteOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName)
}

func (r *ActionsDeleteOrgSecretReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteOrgSecretReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteOrgSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteOrgSecretReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteOrgSecretReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/delete-org-secret", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteOrgSecretReq) Rel(link RelName, resp *ActionsDeleteOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteOrgSecretResponse is a response for ActionsDeleteOrgSecret

https://developer.github.com/v3/actions/secrets/#delete-an-organization-secret
*/
type ActionsDeleteOrgSecretResponse struct {
	response
	request *ActionsDeleteOrgSecretReq
}

/*
ActionsDeleteRepoSecret performs requests for "actions/delete-repo-secret"

Delete a repository secret.

  DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
func ActionsDeleteRepoSecret(ctx context.Context, req *ActionsDeleteRepoSecretReq, opt ...RequestOption) (*ActionsDeleteRepoSecretResponse, error) {
	if req == nil {
		req = new(ActionsDeleteRepoSecretReq)
	}
	resp := &ActionsDeleteRepoSecretResponse{request: req}
	r, err := doRequest(ctx, req, "actions/delete-repo-secret", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/delete-repo-secret")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteRepoSecret performs requests for "actions/delete-repo-secret"

Delete a repository secret.

  DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
func (c Client) ActionsDeleteRepoSecret(ctx context.Context, req *ActionsDeleteRepoSecretReq, opt ...RequestOption) (*ActionsDeleteRepoSecretResponse, error) {
	return ActionsDeleteRepoSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteRepoSecretReq is request data for Client.ActionsDeleteRepoSecret

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
type ActionsDeleteRepoSecretReq struct {
	_url  string
	Owner string
	Repo  string

	// secret_name parameter
	SecretName string
}

func (r *ActionsDeleteRepoSecretReq) url() string {
	return r._url
}

func (r *ActionsDeleteRepoSecretReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName)
}

func (r *ActionsDeleteRepoSecretReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteRepoSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteRepoSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteRepoSecretReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteRepoSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteRepoSecretReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteRepoSecretReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/delete-repo-secret", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteRepoSecretReq) Rel(link RelName, resp *ActionsDeleteRepoSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteRepoSecretResponse is a response for ActionsDeleteRepoSecret

https://developer.github.com/v3/actions/secrets/#delete-a-repository-secret
*/
type ActionsDeleteRepoSecretResponse struct {
	response
	request *ActionsDeleteRepoSecretReq
}

/*
ActionsDeleteSelfHostedRunnerFromOrg performs requests for "actions/delete-self-hosted-runner-from-org"

Delete a self-hosted runner from an organization.

  DELETE /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
func ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, req *ActionsDeleteSelfHostedRunnerFromOrgReq, opt ...RequestOption) (*ActionsDeleteSelfHostedRunnerFromOrgResponse, error) {
	if req == nil {
		req = new(ActionsDeleteSelfHostedRunnerFromOrgReq)
	}
	resp := &ActionsDeleteSelfHostedRunnerFromOrgResponse{request: req}
	r, err := doRequest(ctx, req, "actions/delete-self-hosted-runner-from-org", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/delete-self-hosted-runner-from-org")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteSelfHostedRunnerFromOrg performs requests for "actions/delete-self-hosted-runner-from-org"

Delete a self-hosted runner from an organization.

  DELETE /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
func (c Client) ActionsDeleteSelfHostedRunnerFromOrg(ctx context.Context, req *ActionsDeleteSelfHostedRunnerFromOrgReq, opt ...RequestOption) (*ActionsDeleteSelfHostedRunnerFromOrgResponse, error) {
	return ActionsDeleteSelfHostedRunnerFromOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteSelfHostedRunnerFromOrgReq is request data for Client.ActionsDeleteSelfHostedRunnerFromOrg

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
type ActionsDeleteSelfHostedRunnerFromOrgReq struct {
	_url string
	Org  string

	// runner_id parameter
	RunnerId int64
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) url() string {
	return r._url
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners/%v", r.Org, r.RunnerId)
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/delete-self-hosted-runner-from-org", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteSelfHostedRunnerFromOrgReq) Rel(link RelName, resp *ActionsDeleteSelfHostedRunnerFromOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteSelfHostedRunnerFromOrgResponse is a response for ActionsDeleteSelfHostedRunnerFromOrg

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-an-organization
*/
type ActionsDeleteSelfHostedRunnerFromOrgResponse struct {
	response
	request *ActionsDeleteSelfHostedRunnerFromOrgReq
}

/*
ActionsDeleteSelfHostedRunnerFromRepo performs requests for "actions/delete-self-hosted-runner-from-repo"

Delete a self-hosted runner from a repository.

  DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
func ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, req *ActionsDeleteSelfHostedRunnerFromRepoReq, opt ...RequestOption) (*ActionsDeleteSelfHostedRunnerFromRepoResponse, error) {
	if req == nil {
		req = new(ActionsDeleteSelfHostedRunnerFromRepoReq)
	}
	resp := &ActionsDeleteSelfHostedRunnerFromRepoResponse{request: req}
	r, err := doRequest(ctx, req, "actions/delete-self-hosted-runner-from-repo", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/delete-self-hosted-runner-from-repo")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteSelfHostedRunnerFromRepo performs requests for "actions/delete-self-hosted-runner-from-repo"

Delete a self-hosted runner from a repository.

  DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
func (c Client) ActionsDeleteSelfHostedRunnerFromRepo(ctx context.Context, req *ActionsDeleteSelfHostedRunnerFromRepoReq, opt ...RequestOption) (*ActionsDeleteSelfHostedRunnerFromRepoResponse, error) {
	return ActionsDeleteSelfHostedRunnerFromRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteSelfHostedRunnerFromRepoReq is request data for Client.ActionsDeleteSelfHostedRunnerFromRepo

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
type ActionsDeleteSelfHostedRunnerFromRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// runner_id parameter
	RunnerId int64
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) url() string {
	return r._url
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners/%v", r.Owner, r.Repo, r.RunnerId)
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/delete-self-hosted-runner-from-repo", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteSelfHostedRunnerFromRepoReq) Rel(link RelName, resp *ActionsDeleteSelfHostedRunnerFromRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteSelfHostedRunnerFromRepoResponse is a response for ActionsDeleteSelfHostedRunnerFromRepo

https://developer.github.com/v3/actions/self-hosted-runners/#delete-a-self-hosted-runner-from-a-repository
*/
type ActionsDeleteSelfHostedRunnerFromRepoResponse struct {
	response
	request *ActionsDeleteSelfHostedRunnerFromRepoReq
}

/*
ActionsDeleteWorkflowRun performs requests for "actions/delete-workflow-run"

Delete a workflow run.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
func ActionsDeleteWorkflowRun(ctx context.Context, req *ActionsDeleteWorkflowRunReq, opt ...RequestOption) (*ActionsDeleteWorkflowRunResponse, error) {
	if req == nil {
		req = new(ActionsDeleteWorkflowRunReq)
	}
	resp := &ActionsDeleteWorkflowRunResponse{request: req}
	r, err := doRequest(ctx, req, "actions/delete-workflow-run", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/delete-workflow-run")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteWorkflowRun performs requests for "actions/delete-workflow-run"

Delete a workflow run.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
func (c Client) ActionsDeleteWorkflowRun(ctx context.Context, req *ActionsDeleteWorkflowRunReq, opt ...RequestOption) (*ActionsDeleteWorkflowRunResponse, error) {
	return ActionsDeleteWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteWorkflowRunReq is request data for Client.ActionsDeleteWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
type ActionsDeleteWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsDeleteWorkflowRunReq) url() string {
	return r._url
}

func (r *ActionsDeleteWorkflowRunReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsDeleteWorkflowRunReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteWorkflowRunReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteWorkflowRunReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteWorkflowRunReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteWorkflowRunReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteWorkflowRunReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/delete-workflow-run", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteWorkflowRunReq) Rel(link RelName, resp *ActionsDeleteWorkflowRunResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteWorkflowRunResponse is a response for ActionsDeleteWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#delete-a-workflow-run
*/
type ActionsDeleteWorkflowRunResponse struct {
	response
	request *ActionsDeleteWorkflowRunReq
}

/*
ActionsDeleteWorkflowRunLogs performs requests for "actions/delete-workflow-run-logs"

Delete workflow run logs.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
func ActionsDeleteWorkflowRunLogs(ctx context.Context, req *ActionsDeleteWorkflowRunLogsReq, opt ...RequestOption) (*ActionsDeleteWorkflowRunLogsResponse, error) {
	if req == nil {
		req = new(ActionsDeleteWorkflowRunLogsReq)
	}
	resp := &ActionsDeleteWorkflowRunLogsResponse{request: req}
	r, err := doRequest(ctx, req, "actions/delete-workflow-run-logs", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/delete-workflow-run-logs")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDeleteWorkflowRunLogs performs requests for "actions/delete-workflow-run-logs"

Delete workflow run logs.

  DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
func (c Client) ActionsDeleteWorkflowRunLogs(ctx context.Context, req *ActionsDeleteWorkflowRunLogsReq, opt ...RequestOption) (*ActionsDeleteWorkflowRunLogsResponse, error) {
	return ActionsDeleteWorkflowRunLogs(ctx, req, append(c, opt...)...)
}

/*
ActionsDeleteWorkflowRunLogsReq is request data for Client.ActionsDeleteWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
type ActionsDeleteWorkflowRunLogsReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsDeleteWorkflowRunLogsReq) url() string {
	return r._url
}

func (r *ActionsDeleteWorkflowRunLogsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/logs", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsDeleteWorkflowRunLogsReq) method() string {
	return "DELETE"
}

func (r *ActionsDeleteWorkflowRunLogsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDeleteWorkflowRunLogsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDeleteWorkflowRunLogsReq) body() interface{} {
	return nil
}

func (r *ActionsDeleteWorkflowRunLogsReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDeleteWorkflowRunLogsReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsDeleteWorkflowRunLogsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/delete-workflow-run-logs", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDeleteWorkflowRunLogsReq) Rel(link RelName, resp *ActionsDeleteWorkflowRunLogsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDeleteWorkflowRunLogsResponse is a response for ActionsDeleteWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#delete-workflow-run-logs
*/
type ActionsDeleteWorkflowRunLogsResponse struct {
	response
	request *ActionsDeleteWorkflowRunLogsReq
}

/*
ActionsDownloadArtifact performs requests for "actions/download-artifact"

Download an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
func ActionsDownloadArtifact(ctx context.Context, req *ActionsDownloadArtifactReq, opt ...RequestOption) (*ActionsDownloadArtifactResponse, error) {
	if req == nil {
		req = new(ActionsDownloadArtifactReq)
	}
	resp := &ActionsDownloadArtifactResponse{request: req}
	r, err := doRequest(ctx, req, "actions/download-artifact", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/download-artifact")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDownloadArtifact performs requests for "actions/download-artifact"

Download an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
func (c Client) ActionsDownloadArtifact(ctx context.Context, req *ActionsDownloadArtifactReq, opt ...RequestOption) (*ActionsDownloadArtifactResponse, error) {
	return ActionsDownloadArtifact(ctx, req, append(c, opt...)...)
}

/*
ActionsDownloadArtifactReq is request data for Client.ActionsDownloadArtifact

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
type ActionsDownloadArtifactReq struct {
	_url  string
	Owner string
	Repo  string

	// artifact_id parameter
	ArtifactId int64

	// archive_format parameter
	ArchiveFormat string
}

func (r *ActionsDownloadArtifactReq) url() string {
	return r._url
}

func (r *ActionsDownloadArtifactReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v/%v", r.Owner, r.Repo, r.ArtifactId, r.ArchiveFormat)
}

func (r *ActionsDownloadArtifactReq) method() string {
	return "GET"
}

func (r *ActionsDownloadArtifactReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDownloadArtifactReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDownloadArtifactReq) body() interface{} {
	return nil
}

func (r *ActionsDownloadArtifactReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDownloadArtifactReq) validStatuses() []int {
	return []int{302}
}

// HTTPRequest builds an *http.Request
func (r *ActionsDownloadArtifactReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/download-artifact", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDownloadArtifactReq) Rel(link RelName, resp *ActionsDownloadArtifactResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDownloadArtifactResponse is a response for ActionsDownloadArtifact

https://developer.github.com/v3/actions/artifacts/#download-an-artifact
*/
type ActionsDownloadArtifactResponse struct {
	response
	request *ActionsDownloadArtifactReq
}

/*
ActionsDownloadJobLogsForWorkflowRun performs requests for "actions/download-job-logs-for-workflow-run"

Download job logs for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
func ActionsDownloadJobLogsForWorkflowRun(ctx context.Context, req *ActionsDownloadJobLogsForWorkflowRunReq, opt ...RequestOption) (*ActionsDownloadJobLogsForWorkflowRunResponse, error) {
	if req == nil {
		req = new(ActionsDownloadJobLogsForWorkflowRunReq)
	}
	resp := &ActionsDownloadJobLogsForWorkflowRunResponse{request: req}
	r, err := doRequest(ctx, req, "actions/download-job-logs-for-workflow-run", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/download-job-logs-for-workflow-run")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDownloadJobLogsForWorkflowRun performs requests for "actions/download-job-logs-for-workflow-run"

Download job logs for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
func (c Client) ActionsDownloadJobLogsForWorkflowRun(ctx context.Context, req *ActionsDownloadJobLogsForWorkflowRunReq, opt ...RequestOption) (*ActionsDownloadJobLogsForWorkflowRunResponse, error) {
	return ActionsDownloadJobLogsForWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsDownloadJobLogsForWorkflowRunReq is request data for Client.ActionsDownloadJobLogsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
type ActionsDownloadJobLogsForWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string

	// job_id parameter
	JobId int64
}

func (r *ActionsDownloadJobLogsForWorkflowRunReq) url() string {
	return r._url
}

func (r *ActionsDownloadJobLogsForWorkflowRunReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/jobs/%v/logs", r.Owner, r.Repo, r.JobId)
}

func (r *ActionsDownloadJobLogsForWorkflowRunReq) method() string {
	return "GET"
}

func (r *ActionsDownloadJobLogsForWorkflowRunReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDownloadJobLogsForWorkflowRunReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDownloadJobLogsForWorkflowRunReq) body() interface{} {
	return nil
}

func (r *ActionsDownloadJobLogsForWorkflowRunReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDownloadJobLogsForWorkflowRunReq) validStatuses() []int {
	return []int{302}
}

// HTTPRequest builds an *http.Request
func (r *ActionsDownloadJobLogsForWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/download-job-logs-for-workflow-run", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDownloadJobLogsForWorkflowRunReq) Rel(link RelName, resp *ActionsDownloadJobLogsForWorkflowRunResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDownloadJobLogsForWorkflowRunResponse is a response for ActionsDownloadJobLogsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#download-job-logs-for-a-workflow-run
*/
type ActionsDownloadJobLogsForWorkflowRunResponse struct {
	response
	request *ActionsDownloadJobLogsForWorkflowRunReq
}

/*
ActionsDownloadWorkflowRunLogs performs requests for "actions/download-workflow-run-logs"

Download workflow run logs.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
func ActionsDownloadWorkflowRunLogs(ctx context.Context, req *ActionsDownloadWorkflowRunLogsReq, opt ...RequestOption) (*ActionsDownloadWorkflowRunLogsResponse, error) {
	if req == nil {
		req = new(ActionsDownloadWorkflowRunLogsReq)
	}
	resp := &ActionsDownloadWorkflowRunLogsResponse{request: req}
	r, err := doRequest(ctx, req, "actions/download-workflow-run-logs", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/download-workflow-run-logs")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsDownloadWorkflowRunLogs performs requests for "actions/download-workflow-run-logs"

Download workflow run logs.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
func (c Client) ActionsDownloadWorkflowRunLogs(ctx context.Context, req *ActionsDownloadWorkflowRunLogsReq, opt ...RequestOption) (*ActionsDownloadWorkflowRunLogsResponse, error) {
	return ActionsDownloadWorkflowRunLogs(ctx, req, append(c, opt...)...)
}

/*
ActionsDownloadWorkflowRunLogsReq is request data for Client.ActionsDownloadWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
type ActionsDownloadWorkflowRunLogsReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsDownloadWorkflowRunLogsReq) url() string {
	return r._url
}

func (r *ActionsDownloadWorkflowRunLogsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/logs", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsDownloadWorkflowRunLogsReq) method() string {
	return "GET"
}

func (r *ActionsDownloadWorkflowRunLogsReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsDownloadWorkflowRunLogsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsDownloadWorkflowRunLogsReq) body() interface{} {
	return nil
}

func (r *ActionsDownloadWorkflowRunLogsReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsDownloadWorkflowRunLogsReq) validStatuses() []int {
	return []int{302}
}

// HTTPRequest builds an *http.Request
func (r *ActionsDownloadWorkflowRunLogsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/download-workflow-run-logs", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsDownloadWorkflowRunLogsReq) Rel(link RelName, resp *ActionsDownloadWorkflowRunLogsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsDownloadWorkflowRunLogsResponse is a response for ActionsDownloadWorkflowRunLogs

https://developer.github.com/v3/actions/workflow-runs/#download-workflow-run-logs
*/
type ActionsDownloadWorkflowRunLogsResponse struct {
	response
	request *ActionsDownloadWorkflowRunLogsReq
}

/*
ActionsGetArtifact performs requests for "actions/get-artifact"

Get an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
func ActionsGetArtifact(ctx context.Context, req *ActionsGetArtifactReq, opt ...RequestOption) (*ActionsGetArtifactResponse, error) {
	if req == nil {
		req = new(ActionsGetArtifactReq)
	}
	resp := &ActionsGetArtifactResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-artifact", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Artifact{}
	err = r.decodeBody(&resp.Data, "actions/get-artifact")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetArtifact performs requests for "actions/get-artifact"

Get an artifact.

  GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
func (c Client) ActionsGetArtifact(ctx context.Context, req *ActionsGetArtifactReq, opt ...RequestOption) (*ActionsGetArtifactResponse, error) {
	return ActionsGetArtifact(ctx, req, append(c, opt...)...)
}

/*
ActionsGetArtifactReq is request data for Client.ActionsGetArtifact

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
type ActionsGetArtifactReq struct {
	_url  string
	Owner string
	Repo  string

	// artifact_id parameter
	ArtifactId int64
}

func (r *ActionsGetArtifactReq) url() string {
	return r._url
}

func (r *ActionsGetArtifactReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/artifacts/%v", r.Owner, r.Repo, r.ArtifactId)
}

func (r *ActionsGetArtifactReq) method() string {
	return "GET"
}

func (r *ActionsGetArtifactReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetArtifactReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetArtifactReq) body() interface{} {
	return nil
}

func (r *ActionsGetArtifactReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetArtifactReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetArtifactReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-artifact", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetArtifactReq) Rel(link RelName, resp *ActionsGetArtifactResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetArtifactResponse is a response for ActionsGetArtifact

https://developer.github.com/v3/actions/artifacts/#get-an-artifact
*/
type ActionsGetArtifactResponse struct {
	response
	request *ActionsGetArtifactReq
	Data    components.Artifact
}

/*
ActionsGetJobForWorkflowRun performs requests for "actions/get-job-for-workflow-run"

Get a job for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
func ActionsGetJobForWorkflowRun(ctx context.Context, req *ActionsGetJobForWorkflowRunReq, opt ...RequestOption) (*ActionsGetJobForWorkflowRunResponse, error) {
	if req == nil {
		req = new(ActionsGetJobForWorkflowRunReq)
	}
	resp := &ActionsGetJobForWorkflowRunResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-job-for-workflow-run", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Job{}
	err = r.decodeBody(&resp.Data, "actions/get-job-for-workflow-run")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetJobForWorkflowRun performs requests for "actions/get-job-for-workflow-run"

Get a job for a workflow run.

  GET /repos/{owner}/{repo}/actions/jobs/{job_id}

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
func (c Client) ActionsGetJobForWorkflowRun(ctx context.Context, req *ActionsGetJobForWorkflowRunReq, opt ...RequestOption) (*ActionsGetJobForWorkflowRunResponse, error) {
	return ActionsGetJobForWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsGetJobForWorkflowRunReq is request data for Client.ActionsGetJobForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
type ActionsGetJobForWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string

	// job_id parameter
	JobId int64
}

func (r *ActionsGetJobForWorkflowRunReq) url() string {
	return r._url
}

func (r *ActionsGetJobForWorkflowRunReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/jobs/%v", r.Owner, r.Repo, r.JobId)
}

func (r *ActionsGetJobForWorkflowRunReq) method() string {
	return "GET"
}

func (r *ActionsGetJobForWorkflowRunReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetJobForWorkflowRunReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetJobForWorkflowRunReq) body() interface{} {
	return nil
}

func (r *ActionsGetJobForWorkflowRunReq) dataStatuses() []int {
	return []int{202}
}

func (r *ActionsGetJobForWorkflowRunReq) validStatuses() []int {
	return []int{202}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetJobForWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-job-for-workflow-run", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetJobForWorkflowRunReq) Rel(link RelName, resp *ActionsGetJobForWorkflowRunResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetJobForWorkflowRunResponse is a response for ActionsGetJobForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#get-a-job-for-a-workflow-run
*/
type ActionsGetJobForWorkflowRunResponse struct {
	response
	request *ActionsGetJobForWorkflowRunReq
	Data    components.Job
}

/*
ActionsGetOrgPublicKey performs requests for "actions/get-org-public-key"

Get an organization public key.

  GET /orgs/{org}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
func ActionsGetOrgPublicKey(ctx context.Context, req *ActionsGetOrgPublicKeyReq, opt ...RequestOption) (*ActionsGetOrgPublicKeyResponse, error) {
	if req == nil {
		req = new(ActionsGetOrgPublicKeyReq)
	}
	resp := &ActionsGetOrgPublicKeyResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-org-public-key", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.ActionsPublicKey{}
	err = r.decodeBody(&resp.Data, "actions/get-org-public-key")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetOrgPublicKey performs requests for "actions/get-org-public-key"

Get an organization public key.

  GET /orgs/{org}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
func (c Client) ActionsGetOrgPublicKey(ctx context.Context, req *ActionsGetOrgPublicKeyReq, opt ...RequestOption) (*ActionsGetOrgPublicKeyResponse, error) {
	return ActionsGetOrgPublicKey(ctx, req, append(c, opt...)...)
}

/*
ActionsGetOrgPublicKeyReq is request data for Client.ActionsGetOrgPublicKey

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
type ActionsGetOrgPublicKeyReq struct {
	_url string
	Org  string
}

func (r *ActionsGetOrgPublicKeyReq) url() string {
	return r._url
}

func (r *ActionsGetOrgPublicKeyReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/public-key", r.Org)
}

func (r *ActionsGetOrgPublicKeyReq) method() string {
	return "GET"
}

func (r *ActionsGetOrgPublicKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetOrgPublicKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetOrgPublicKeyReq) body() interface{} {
	return nil
}

func (r *ActionsGetOrgPublicKeyReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetOrgPublicKeyReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetOrgPublicKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-org-public-key", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetOrgPublicKeyReq) Rel(link RelName, resp *ActionsGetOrgPublicKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetOrgPublicKeyResponse is a response for ActionsGetOrgPublicKey

https://developer.github.com/v3/actions/secrets/#get-an-organization-public-key
*/
type ActionsGetOrgPublicKeyResponse struct {
	response
	request *ActionsGetOrgPublicKeyReq
	Data    components.ActionsPublicKey
}

/*
ActionsGetOrgSecret performs requests for "actions/get-org-secret"

Get an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
func ActionsGetOrgSecret(ctx context.Context, req *ActionsGetOrgSecretReq, opt ...RequestOption) (*ActionsGetOrgSecretResponse, error) {
	if req == nil {
		req = new(ActionsGetOrgSecretReq)
	}
	resp := &ActionsGetOrgSecretResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-org-secret", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.OrganizationActionsSecret{}
	err = r.decodeBody(&resp.Data, "actions/get-org-secret")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetOrgSecret performs requests for "actions/get-org-secret"

Get an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
func (c Client) ActionsGetOrgSecret(ctx context.Context, req *ActionsGetOrgSecretReq, opt ...RequestOption) (*ActionsGetOrgSecretResponse, error) {
	return ActionsGetOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsGetOrgSecretReq is request data for Client.ActionsGetOrgSecret

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
type ActionsGetOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string
}

func (r *ActionsGetOrgSecretReq) url() string {
	return r._url
}

func (r *ActionsGetOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v", r.Org, r.SecretName)
}

func (r *ActionsGetOrgSecretReq) method() string {
	return "GET"
}

func (r *ActionsGetOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetOrgSecretReq) body() interface{} {
	return nil
}

func (r *ActionsGetOrgSecretReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetOrgSecretReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetOrgSecretReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-org-secret", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetOrgSecretReq) Rel(link RelName, resp *ActionsGetOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetOrgSecretResponse is a response for ActionsGetOrgSecret

https://developer.github.com/v3/actions/secrets/#get-an-organization-secret
*/
type ActionsGetOrgSecretResponse struct {
	response
	request *ActionsGetOrgSecretReq
	Data    components.OrganizationActionsSecret
}

/*
ActionsGetRepoPublicKey performs requests for "actions/get-repo-public-key"

Get a repository public key.

  GET /repos/{owner}/{repo}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
func ActionsGetRepoPublicKey(ctx context.Context, req *ActionsGetRepoPublicKeyReq, opt ...RequestOption) (*ActionsGetRepoPublicKeyResponse, error) {
	if req == nil {
		req = new(ActionsGetRepoPublicKeyReq)
	}
	resp := &ActionsGetRepoPublicKeyResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-repo-public-key", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.ActionsPublicKey{}
	err = r.decodeBody(&resp.Data, "actions/get-repo-public-key")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetRepoPublicKey performs requests for "actions/get-repo-public-key"

Get a repository public key.

  GET /repos/{owner}/{repo}/actions/secrets/public-key

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
func (c Client) ActionsGetRepoPublicKey(ctx context.Context, req *ActionsGetRepoPublicKeyReq, opt ...RequestOption) (*ActionsGetRepoPublicKeyResponse, error) {
	return ActionsGetRepoPublicKey(ctx, req, append(c, opt...)...)
}

/*
ActionsGetRepoPublicKeyReq is request data for Client.ActionsGetRepoPublicKey

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
type ActionsGetRepoPublicKeyReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ActionsGetRepoPublicKeyReq) url() string {
	return r._url
}

func (r *ActionsGetRepoPublicKeyReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/secrets/public-key", r.Owner, r.Repo)
}

func (r *ActionsGetRepoPublicKeyReq) method() string {
	return "GET"
}

func (r *ActionsGetRepoPublicKeyReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetRepoPublicKeyReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetRepoPublicKeyReq) body() interface{} {
	return nil
}

func (r *ActionsGetRepoPublicKeyReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetRepoPublicKeyReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetRepoPublicKeyReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-repo-public-key", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetRepoPublicKeyReq) Rel(link RelName, resp *ActionsGetRepoPublicKeyResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetRepoPublicKeyResponse is a response for ActionsGetRepoPublicKey

https://developer.github.com/v3/actions/secrets/#get-a-repository-public-key
*/
type ActionsGetRepoPublicKeyResponse struct {
	response
	request *ActionsGetRepoPublicKeyReq
	Data    components.ActionsPublicKey
}

/*
ActionsGetRepoSecret performs requests for "actions/get-repo-secret"

Get a repository secret.

  GET /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
func ActionsGetRepoSecret(ctx context.Context, req *ActionsGetRepoSecretReq, opt ...RequestOption) (*ActionsGetRepoSecretResponse, error) {
	if req == nil {
		req = new(ActionsGetRepoSecretReq)
	}
	resp := &ActionsGetRepoSecretResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-repo-secret", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.ActionsSecret{}
	err = r.decodeBody(&resp.Data, "actions/get-repo-secret")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetRepoSecret performs requests for "actions/get-repo-secret"

Get a repository secret.

  GET /repos/{owner}/{repo}/actions/secrets/{secret_name}

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
func (c Client) ActionsGetRepoSecret(ctx context.Context, req *ActionsGetRepoSecretReq, opt ...RequestOption) (*ActionsGetRepoSecretResponse, error) {
	return ActionsGetRepoSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsGetRepoSecretReq is request data for Client.ActionsGetRepoSecret

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
type ActionsGetRepoSecretReq struct {
	_url  string
	Owner string
	Repo  string

	// secret_name parameter
	SecretName string
}

func (r *ActionsGetRepoSecretReq) url() string {
	return r._url
}

func (r *ActionsGetRepoSecretReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/secrets/%v", r.Owner, r.Repo, r.SecretName)
}

func (r *ActionsGetRepoSecretReq) method() string {
	return "GET"
}

func (r *ActionsGetRepoSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetRepoSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetRepoSecretReq) body() interface{} {
	return nil
}

func (r *ActionsGetRepoSecretReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetRepoSecretReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetRepoSecretReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-repo-secret", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetRepoSecretReq) Rel(link RelName, resp *ActionsGetRepoSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetRepoSecretResponse is a response for ActionsGetRepoSecret

https://developer.github.com/v3/actions/secrets/#get-a-repository-secret
*/
type ActionsGetRepoSecretResponse struct {
	response
	request *ActionsGetRepoSecretReq
	Data    components.ActionsSecret
}

/*
ActionsGetSelfHostedRunnerForOrg performs requests for "actions/get-self-hosted-runner-for-org"

Get a self-hosted runner for an organization.

  GET /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
func ActionsGetSelfHostedRunnerForOrg(ctx context.Context, req *ActionsGetSelfHostedRunnerForOrgReq, opt ...RequestOption) (*ActionsGetSelfHostedRunnerForOrgResponse, error) {
	if req == nil {
		req = new(ActionsGetSelfHostedRunnerForOrgReq)
	}
	resp := &ActionsGetSelfHostedRunnerForOrgResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-self-hosted-runner-for-org", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Runner{}
	err = r.decodeBody(&resp.Data, "actions/get-self-hosted-runner-for-org")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetSelfHostedRunnerForOrg performs requests for "actions/get-self-hosted-runner-for-org"

Get a self-hosted runner for an organization.

  GET /orgs/{org}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
func (c Client) ActionsGetSelfHostedRunnerForOrg(ctx context.Context, req *ActionsGetSelfHostedRunnerForOrgReq, opt ...RequestOption) (*ActionsGetSelfHostedRunnerForOrgResponse, error) {
	return ActionsGetSelfHostedRunnerForOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsGetSelfHostedRunnerForOrgReq is request data for Client.ActionsGetSelfHostedRunnerForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
type ActionsGetSelfHostedRunnerForOrgReq struct {
	_url string
	Org  string

	// runner_id parameter
	RunnerId int64
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) url() string {
	return r._url
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners/%v", r.Org, r.RunnerId)
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) method() string {
	return "GET"
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) body() interface{} {
	return nil
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetSelfHostedRunnerForOrgReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetSelfHostedRunnerForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-self-hosted-runner-for-org", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetSelfHostedRunnerForOrgReq) Rel(link RelName, resp *ActionsGetSelfHostedRunnerForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetSelfHostedRunnerForOrgResponse is a response for ActionsGetSelfHostedRunnerForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-an-organization
*/
type ActionsGetSelfHostedRunnerForOrgResponse struct {
	response
	request *ActionsGetSelfHostedRunnerForOrgReq
	Data    components.Runner
}

/*
ActionsGetSelfHostedRunnerForRepo performs requests for "actions/get-self-hosted-runner-for-repo"

Get a self-hosted runner for a repository.

  GET /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
func ActionsGetSelfHostedRunnerForRepo(ctx context.Context, req *ActionsGetSelfHostedRunnerForRepoReq, opt ...RequestOption) (*ActionsGetSelfHostedRunnerForRepoResponse, error) {
	if req == nil {
		req = new(ActionsGetSelfHostedRunnerForRepoReq)
	}
	resp := &ActionsGetSelfHostedRunnerForRepoResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-self-hosted-runner-for-repo", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Runner{}
	err = r.decodeBody(&resp.Data, "actions/get-self-hosted-runner-for-repo")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetSelfHostedRunnerForRepo performs requests for "actions/get-self-hosted-runner-for-repo"

Get a self-hosted runner for a repository.

  GET /repos/{owner}/{repo}/actions/runners/{runner_id}

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
func (c Client) ActionsGetSelfHostedRunnerForRepo(ctx context.Context, req *ActionsGetSelfHostedRunnerForRepoReq, opt ...RequestOption) (*ActionsGetSelfHostedRunnerForRepoResponse, error) {
	return ActionsGetSelfHostedRunnerForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsGetSelfHostedRunnerForRepoReq is request data for Client.ActionsGetSelfHostedRunnerForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
type ActionsGetSelfHostedRunnerForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// runner_id parameter
	RunnerId int64
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) url() string {
	return r._url
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners/%v", r.Owner, r.Repo, r.RunnerId)
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) method() string {
	return "GET"
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetSelfHostedRunnerForRepoReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetSelfHostedRunnerForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-self-hosted-runner-for-repo", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetSelfHostedRunnerForRepoReq) Rel(link RelName, resp *ActionsGetSelfHostedRunnerForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetSelfHostedRunnerForRepoResponse is a response for ActionsGetSelfHostedRunnerForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#get-a-self-hosted-runner-for-a-repository
*/
type ActionsGetSelfHostedRunnerForRepoResponse struct {
	response
	request *ActionsGetSelfHostedRunnerForRepoReq
	Data    components.Runner
}

/*
ActionsGetWorkflow performs requests for "actions/get-workflow"

Get a workflow.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
func ActionsGetWorkflow(ctx context.Context, req *ActionsGetWorkflowReq, opt ...RequestOption) (*ActionsGetWorkflowResponse, error) {
	if req == nil {
		req = new(ActionsGetWorkflowReq)
	}
	resp := &ActionsGetWorkflowResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-workflow", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.Workflow{}
	err = r.decodeBody(&resp.Data, "actions/get-workflow")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflow performs requests for "actions/get-workflow"

Get a workflow.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
func (c Client) ActionsGetWorkflow(ctx context.Context, req *ActionsGetWorkflowReq, opt ...RequestOption) (*ActionsGetWorkflowResponse, error) {
	return ActionsGetWorkflow(ctx, req, append(c, opt...)...)
}

/*
ActionsGetWorkflowReq is request data for Client.ActionsGetWorkflow

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
type ActionsGetWorkflowReq struct {
	_url       string
	Owner      string
	Repo       string
	WorkflowId int64
}

func (r *ActionsGetWorkflowReq) url() string {
	return r._url
}

func (r *ActionsGetWorkflowReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/workflows/%v", r.Owner, r.Repo, r.WorkflowId)
}

func (r *ActionsGetWorkflowReq) method() string {
	return "GET"
}

func (r *ActionsGetWorkflowReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetWorkflowReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetWorkflowReq) body() interface{} {
	return nil
}

func (r *ActionsGetWorkflowReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetWorkflowReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-workflow", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowReq) Rel(link RelName, resp *ActionsGetWorkflowResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetWorkflowResponse is a response for ActionsGetWorkflow

https://developer.github.com/v3/actions/workflows/#get-a-workflow
*/
type ActionsGetWorkflowResponse struct {
	response
	request *ActionsGetWorkflowReq
	Data    components.Workflow
}

/*
ActionsGetWorkflowRun performs requests for "actions/get-workflow-run"

Get a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
func ActionsGetWorkflowRun(ctx context.Context, req *ActionsGetWorkflowRunReq, opt ...RequestOption) (*ActionsGetWorkflowRunResponse, error) {
	if req == nil {
		req = new(ActionsGetWorkflowRunReq)
	}
	resp := &ActionsGetWorkflowRunResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-workflow-run", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.WorkflowRun{}
	err = r.decodeBody(&resp.Data, "actions/get-workflow-run")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflowRun performs requests for "actions/get-workflow-run"

Get a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
func (c Client) ActionsGetWorkflowRun(ctx context.Context, req *ActionsGetWorkflowRunReq, opt ...RequestOption) (*ActionsGetWorkflowRunResponse, error) {
	return ActionsGetWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsGetWorkflowRunReq is request data for Client.ActionsGetWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
type ActionsGetWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsGetWorkflowRunReq) url() string {
	return r._url
}

func (r *ActionsGetWorkflowRunReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsGetWorkflowRunReq) method() string {
	return "GET"
}

func (r *ActionsGetWorkflowRunReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetWorkflowRunReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetWorkflowRunReq) body() interface{} {
	return nil
}

func (r *ActionsGetWorkflowRunReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowRunReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-workflow-run", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowRunReq) Rel(link RelName, resp *ActionsGetWorkflowRunResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetWorkflowRunResponse is a response for ActionsGetWorkflowRun

https://developer.github.com/v3/actions/workflow-runs/#get-a-workflow-run
*/
type ActionsGetWorkflowRunResponse struct {
	response
	request *ActionsGetWorkflowRunReq
	Data    components.WorkflowRun
}

/*
ActionsGetWorkflowRunUsage performs requests for "actions/get-workflow-run-usage"

Get workflow run usage.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
func ActionsGetWorkflowRunUsage(ctx context.Context, req *ActionsGetWorkflowRunUsageReq, opt ...RequestOption) (*ActionsGetWorkflowRunUsageResponse, error) {
	if req == nil {
		req = new(ActionsGetWorkflowRunUsageReq)
	}
	resp := &ActionsGetWorkflowRunUsageResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-workflow-run-usage", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.WorkflowRunUsage{}
	err = r.decodeBody(&resp.Data, "actions/get-workflow-run-usage")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflowRunUsage performs requests for "actions/get-workflow-run-usage"

Get workflow run usage.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
func (c Client) ActionsGetWorkflowRunUsage(ctx context.Context, req *ActionsGetWorkflowRunUsageReq, opt ...RequestOption) (*ActionsGetWorkflowRunUsageResponse, error) {
	return ActionsGetWorkflowRunUsage(ctx, req, append(c, opt...)...)
}

/*
ActionsGetWorkflowRunUsageReq is request data for Client.ActionsGetWorkflowRunUsage

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
type ActionsGetWorkflowRunUsageReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsGetWorkflowRunUsageReq) url() string {
	return r._url
}

func (r *ActionsGetWorkflowRunUsageReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/timing", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsGetWorkflowRunUsageReq) method() string {
	return "GET"
}

func (r *ActionsGetWorkflowRunUsageReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetWorkflowRunUsageReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetWorkflowRunUsageReq) body() interface{} {
	return nil
}

func (r *ActionsGetWorkflowRunUsageReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowRunUsageReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetWorkflowRunUsageReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-workflow-run-usage", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowRunUsageReq) Rel(link RelName, resp *ActionsGetWorkflowRunUsageResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetWorkflowRunUsageResponse is a response for ActionsGetWorkflowRunUsage

https://developer.github.com/v3/actions/workflow-runs/#get-workflow-run-usage
*/
type ActionsGetWorkflowRunUsageResponse struct {
	response
	request *ActionsGetWorkflowRunUsageReq
	Data    components.WorkflowRunUsage
}

/*
ActionsGetWorkflowUsage performs requests for "actions/get-workflow-usage"

Get workflow usage.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
func ActionsGetWorkflowUsage(ctx context.Context, req *ActionsGetWorkflowUsageReq, opt ...RequestOption) (*ActionsGetWorkflowUsageResponse, error) {
	if req == nil {
		req = new(ActionsGetWorkflowUsageReq)
	}
	resp := &ActionsGetWorkflowUsageResponse{request: req}
	r, err := doRequest(ctx, req, "actions/get-workflow-usage", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = components.WorkflowUsage{}
	err = r.decodeBody(&resp.Data, "actions/get-workflow-usage")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsGetWorkflowUsage performs requests for "actions/get-workflow-usage"

Get workflow usage.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
func (c Client) ActionsGetWorkflowUsage(ctx context.Context, req *ActionsGetWorkflowUsageReq, opt ...RequestOption) (*ActionsGetWorkflowUsageResponse, error) {
	return ActionsGetWorkflowUsage(ctx, req, append(c, opt...)...)
}

/*
ActionsGetWorkflowUsageReq is request data for Client.ActionsGetWorkflowUsage

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
type ActionsGetWorkflowUsageReq struct {
	_url       string
	Owner      string
	Repo       string
	WorkflowId int64
}

func (r *ActionsGetWorkflowUsageReq) url() string {
	return r._url
}

func (r *ActionsGetWorkflowUsageReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/workflows/%v/timing", r.Owner, r.Repo, r.WorkflowId)
}

func (r *ActionsGetWorkflowUsageReq) method() string {
	return "GET"
}

func (r *ActionsGetWorkflowUsageReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsGetWorkflowUsageReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsGetWorkflowUsageReq) body() interface{} {
	return nil
}

func (r *ActionsGetWorkflowUsageReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsGetWorkflowUsageReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsGetWorkflowUsageReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/get-workflow-usage", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsGetWorkflowUsageReq) Rel(link RelName, resp *ActionsGetWorkflowUsageResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsGetWorkflowUsageResponse is a response for ActionsGetWorkflowUsage

https://developer.github.com/v3/actions/workflows/#get-workflow-usage
*/
type ActionsGetWorkflowUsageResponse struct {
	response
	request *ActionsGetWorkflowUsageReq
	Data    components.WorkflowUsage
}

/*
ActionsListArtifactsForRepo performs requests for "actions/list-artifacts-for-repo"

List artifacts for a repository.

  GET /repos/{owner}/{repo}/actions/artifacts

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
func ActionsListArtifactsForRepo(ctx context.Context, req *ActionsListArtifactsForRepoReq, opt ...RequestOption) (*ActionsListArtifactsForRepoResponse, error) {
	if req == nil {
		req = new(ActionsListArtifactsForRepoReq)
	}
	resp := &ActionsListArtifactsForRepoResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-artifacts-for-repo", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ActionsListArtifactsForRepoResponseBody{}
	err = r.decodeBody(&resp.Data, "actions/list-artifacts-for-repo")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListArtifactsForRepo performs requests for "actions/list-artifacts-for-repo"

List artifacts for a repository.

  GET /repos/{owner}/{repo}/actions/artifacts

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
func (c Client) ActionsListArtifactsForRepo(ctx context.Context, req *ActionsListArtifactsForRepoReq, opt ...RequestOption) (*ActionsListArtifactsForRepoResponse, error) {
	return ActionsListArtifactsForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsListArtifactsForRepoReq is request data for Client.ActionsListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ActionsListArtifactsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListArtifactsForRepoReq) url() string {
	return r._url
}

func (r *ActionsListArtifactsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/artifacts", r.Owner, r.Repo)
}

func (r *ActionsListArtifactsForRepoReq) method() string {
	return "GET"
}

func (r *ActionsListArtifactsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListArtifactsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListArtifactsForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsListArtifactsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListArtifactsForRepoReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListArtifactsForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-artifacts-for-repo", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListArtifactsForRepoReq) Rel(link RelName, resp *ActionsListArtifactsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListArtifactsForRepoResponseBody is a response body for ActionsListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ActionsListArtifactsForRepoResponseBody struct {
	Artifacts  []components.Artifact `json:"artifacts,omitempty"`
	TotalCount int64                 `json:"total_count,omitempty"`
}

/*
ActionsListArtifactsForRepoResponse is a response for ActionsListArtifactsForRepo

https://developer.github.com/v3/actions/artifacts/#list-artifacts-for-a-repository
*/
type ActionsListArtifactsForRepoResponse struct {
	response
	request *ActionsListArtifactsForRepoReq
	Data    ActionsListArtifactsForRepoResponseBody
}

/*
ActionsListJobsForWorkflowRun performs requests for "actions/list-jobs-for-workflow-run"

List jobs for a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
func ActionsListJobsForWorkflowRun(ctx context.Context, req *ActionsListJobsForWorkflowRunReq, opt ...RequestOption) (*ActionsListJobsForWorkflowRunResponse, error) {
	if req == nil {
		req = new(ActionsListJobsForWorkflowRunReq)
	}
	resp := &ActionsListJobsForWorkflowRunResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-jobs-for-workflow-run", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ActionsListJobsForWorkflowRunResponseBody{}
	err = r.decodeBody(&resp.Data, "actions/list-jobs-for-workflow-run")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListJobsForWorkflowRun performs requests for "actions/list-jobs-for-workflow-run"

List jobs for a workflow run.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
func (c Client) ActionsListJobsForWorkflowRun(ctx context.Context, req *ActionsListJobsForWorkflowRunReq, opt ...RequestOption) (*ActionsListJobsForWorkflowRunResponse, error) {
	return ActionsListJobsForWorkflowRun(ctx, req, append(c, opt...)...)
}

/*
ActionsListJobsForWorkflowRunReq is request data for Client.ActionsListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ActionsListJobsForWorkflowRunReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64

	/*
	Filters jobs by their `completed_at` timestamp. Can be one of:
	\* `latest`: Returns jobs from the most recent execution of the workflow run.
	\* `all`: Returns all jobs for a workflow run, including from old executions of
	the workflow run.
	*/
	Filter *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListJobsForWorkflowRunReq) url() string {
	return r._url
}

func (r *ActionsListJobsForWorkflowRunReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/jobs", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsListJobsForWorkflowRunReq) method() string {
	return "GET"
}

func (r *ActionsListJobsForWorkflowRunReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Filter != nil {
		query.Set("filter", *r.Filter)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListJobsForWorkflowRunReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListJobsForWorkflowRunReq) body() interface{} {
	return nil
}

func (r *ActionsListJobsForWorkflowRunReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListJobsForWorkflowRunReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListJobsForWorkflowRunReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-jobs-for-workflow-run", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListJobsForWorkflowRunReq) Rel(link RelName, resp *ActionsListJobsForWorkflowRunResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListJobsForWorkflowRunResponseBody is a response body for ActionsListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ActionsListJobsForWorkflowRunResponseBody struct {
	Jobs       []components.Job `json:"jobs,omitempty"`
	TotalCount int64            `json:"total_count,omitempty"`
}

/*
ActionsListJobsForWorkflowRunResponse is a response for ActionsListJobsForWorkflowRun

https://developer.github.com/v3/actions/workflow-jobs/#list-jobs-for-a-workflow-run
*/
type ActionsListJobsForWorkflowRunResponse struct {
	response
	request *ActionsListJobsForWorkflowRunReq
	Data    ActionsListJobsForWorkflowRunResponseBody
}

/*
ActionsListOrgSecrets performs requests for "actions/list-org-secrets"

List organization secrets.

  GET /orgs/{org}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
func ActionsListOrgSecrets(ctx context.Context, req *ActionsListOrgSecretsReq, opt ...RequestOption) (*ActionsListOrgSecretsResponse, error) {
	if req == nil {
		req = new(ActionsListOrgSecretsReq)
	}
	resp := &ActionsListOrgSecretsResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-org-secrets", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ActionsListOrgSecretsResponseBody{}
	err = r.decodeBody(&resp.Data, "actions/list-org-secrets")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListOrgSecrets performs requests for "actions/list-org-secrets"

List organization secrets.

  GET /orgs/{org}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
func (c Client) ActionsListOrgSecrets(ctx context.Context, req *ActionsListOrgSecretsReq, opt ...RequestOption) (*ActionsListOrgSecretsResponse, error) {
	return ActionsListOrgSecrets(ctx, req, append(c, opt...)...)
}

/*
ActionsListOrgSecretsReq is request data for Client.ActionsListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ActionsListOrgSecretsReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListOrgSecretsReq) url() string {
	return r._url
}

func (r *ActionsListOrgSecretsReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets", r.Org)
}

func (r *ActionsListOrgSecretsReq) method() string {
	return "GET"
}

func (r *ActionsListOrgSecretsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListOrgSecretsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListOrgSecretsReq) body() interface{} {
	return nil
}

func (r *ActionsListOrgSecretsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListOrgSecretsReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListOrgSecretsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-org-secrets", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListOrgSecretsReq) Rel(link RelName, resp *ActionsListOrgSecretsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListOrgSecretsResponseBody is a response body for ActionsListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ActionsListOrgSecretsResponseBody struct {
	Secrets    []components.OrganizationActionsSecret `json:"secrets,omitempty"`
	TotalCount int64                                  `json:"total_count,omitempty"`
}

/*
ActionsListOrgSecretsResponse is a response for ActionsListOrgSecrets

https://developer.github.com/v3/actions/secrets/#list-organization-secrets
*/
type ActionsListOrgSecretsResponse struct {
	response
	request *ActionsListOrgSecretsReq
	Data    ActionsListOrgSecretsResponseBody
}

/*
ActionsListRepoSecrets performs requests for "actions/list-repo-secrets"

List repository secrets.

  GET /repos/{owner}/{repo}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
func ActionsListRepoSecrets(ctx context.Context, req *ActionsListRepoSecretsReq, opt ...RequestOption) (*ActionsListRepoSecretsResponse, error) {
	if req == nil {
		req = new(ActionsListRepoSecretsReq)
	}
	resp := &ActionsListRepoSecretsResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-repo-secrets", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ActionsListRepoSecretsResponseBody{}
	err = r.decodeBody(&resp.Data, "actions/list-repo-secrets")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRepoSecrets performs requests for "actions/list-repo-secrets"

List repository secrets.

  GET /repos/{owner}/{repo}/actions/secrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
func (c Client) ActionsListRepoSecrets(ctx context.Context, req *ActionsListRepoSecretsReq, opt ...RequestOption) (*ActionsListRepoSecretsResponse, error) {
	return ActionsListRepoSecrets(ctx, req, append(c, opt...)...)
}

/*
ActionsListRepoSecretsReq is request data for Client.ActionsListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ActionsListRepoSecretsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListRepoSecretsReq) url() string {
	return r._url
}

func (r *ActionsListRepoSecretsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/secrets", r.Owner, r.Repo)
}

func (r *ActionsListRepoSecretsReq) method() string {
	return "GET"
}

func (r *ActionsListRepoSecretsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListRepoSecretsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListRepoSecretsReq) body() interface{} {
	return nil
}

func (r *ActionsListRepoSecretsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListRepoSecretsReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListRepoSecretsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-repo-secrets", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRepoSecretsReq) Rel(link RelName, resp *ActionsListRepoSecretsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListRepoSecretsResponseBody is a response body for ActionsListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ActionsListRepoSecretsResponseBody struct {
	Secrets    []components.ActionsSecret `json:"secrets,omitempty"`
	TotalCount int64                      `json:"total_count,omitempty"`
}

/*
ActionsListRepoSecretsResponse is a response for ActionsListRepoSecrets

https://developer.github.com/v3/actions/secrets/#list-repository-secrets
*/
type ActionsListRepoSecretsResponse struct {
	response
	request *ActionsListRepoSecretsReq
	Data    ActionsListRepoSecretsResponseBody
}

/*
ActionsListRepoWorkflows performs requests for "actions/list-repo-workflows"

List repository workflows.

  GET /repos/{owner}/{repo}/actions/workflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
func ActionsListRepoWorkflows(ctx context.Context, req *ActionsListRepoWorkflowsReq, opt ...RequestOption) (*ActionsListRepoWorkflowsResponse, error) {
	if req == nil {
		req = new(ActionsListRepoWorkflowsReq)
	}
	resp := &ActionsListRepoWorkflowsResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-repo-workflows", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ActionsListRepoWorkflowsResponseBody{}
	err = r.decodeBody(&resp.Data, "actions/list-repo-workflows")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRepoWorkflows performs requests for "actions/list-repo-workflows"

List repository workflows.

  GET /repos/{owner}/{repo}/actions/workflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
func (c Client) ActionsListRepoWorkflows(ctx context.Context, req *ActionsListRepoWorkflowsReq, opt ...RequestOption) (*ActionsListRepoWorkflowsResponse, error) {
	return ActionsListRepoWorkflows(ctx, req, append(c, opt...)...)
}

/*
ActionsListRepoWorkflowsReq is request data for Client.ActionsListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ActionsListRepoWorkflowsReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListRepoWorkflowsReq) url() string {
	return r._url
}

func (r *ActionsListRepoWorkflowsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/workflows", r.Owner, r.Repo)
}

func (r *ActionsListRepoWorkflowsReq) method() string {
	return "GET"
}

func (r *ActionsListRepoWorkflowsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListRepoWorkflowsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListRepoWorkflowsReq) body() interface{} {
	return nil
}

func (r *ActionsListRepoWorkflowsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListRepoWorkflowsReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListRepoWorkflowsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-repo-workflows", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRepoWorkflowsReq) Rel(link RelName, resp *ActionsListRepoWorkflowsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListRepoWorkflowsResponseBody is a response body for ActionsListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ActionsListRepoWorkflowsResponseBody struct {
	TotalCount int64                 `json:"total_count,omitempty"`
	Workflows  []components.Workflow `json:"workflows,omitempty"`
}

/*
ActionsListRepoWorkflowsResponse is a response for ActionsListRepoWorkflows

https://developer.github.com/v3/actions/workflows/#list-repository-workflows
*/
type ActionsListRepoWorkflowsResponse struct {
	response
	request *ActionsListRepoWorkflowsReq
	Data    ActionsListRepoWorkflowsResponseBody
}

/*
ActionsListRunnerApplicationsForOrg performs requests for "actions/list-runner-applications-for-org"

List runner applications for an organization.

  GET /orgs/{org}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
func ActionsListRunnerApplicationsForOrg(ctx context.Context, req *ActionsListRunnerApplicationsForOrgReq, opt ...RequestOption) (*ActionsListRunnerApplicationsForOrgResponse, error) {
	if req == nil {
		req = new(ActionsListRunnerApplicationsForOrgReq)
	}
	resp := &ActionsListRunnerApplicationsForOrgResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-runner-applications-for-org", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.RunnerApplication{}
	err = r.decodeBody(&resp.Data, "actions/list-runner-applications-for-org")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRunnerApplicationsForOrg performs requests for "actions/list-runner-applications-for-org"

List runner applications for an organization.

  GET /orgs/{org}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
func (c Client) ActionsListRunnerApplicationsForOrg(ctx context.Context, req *ActionsListRunnerApplicationsForOrgReq, opt ...RequestOption) (*ActionsListRunnerApplicationsForOrgResponse, error) {
	return ActionsListRunnerApplicationsForOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsListRunnerApplicationsForOrgReq is request data for Client.ActionsListRunnerApplicationsForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
type ActionsListRunnerApplicationsForOrgReq struct {
	_url string
	Org  string
}

func (r *ActionsListRunnerApplicationsForOrgReq) url() string {
	return r._url
}

func (r *ActionsListRunnerApplicationsForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners/downloads", r.Org)
}

func (r *ActionsListRunnerApplicationsForOrgReq) method() string {
	return "GET"
}

func (r *ActionsListRunnerApplicationsForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsListRunnerApplicationsForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListRunnerApplicationsForOrgReq) body() interface{} {
	return nil
}

func (r *ActionsListRunnerApplicationsForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListRunnerApplicationsForOrgReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListRunnerApplicationsForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-runner-applications-for-org", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRunnerApplicationsForOrgReq) Rel(link RelName, resp *ActionsListRunnerApplicationsForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListRunnerApplicationsForOrgResponse is a response for ActionsListRunnerApplicationsForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-an-organization
*/
type ActionsListRunnerApplicationsForOrgResponse struct {
	response
	request *ActionsListRunnerApplicationsForOrgReq
	Data    []components.RunnerApplication
}

/*
ActionsListRunnerApplicationsForRepo performs requests for "actions/list-runner-applications-for-repo"

List runner applications for a repository.

  GET /repos/{owner}/{repo}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
func ActionsListRunnerApplicationsForRepo(ctx context.Context, req *ActionsListRunnerApplicationsForRepoReq, opt ...RequestOption) (*ActionsListRunnerApplicationsForRepoResponse, error) {
	if req == nil {
		req = new(ActionsListRunnerApplicationsForRepoReq)
	}
	resp := &ActionsListRunnerApplicationsForRepoResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-runner-applications-for-repo", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = []components.RunnerApplication{}
	err = r.decodeBody(&resp.Data, "actions/list-runner-applications-for-repo")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListRunnerApplicationsForRepo performs requests for "actions/list-runner-applications-for-repo"

List runner applications for a repository.

  GET /repos/{owner}/{repo}/actions/runners/downloads

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
func (c Client) ActionsListRunnerApplicationsForRepo(ctx context.Context, req *ActionsListRunnerApplicationsForRepoReq, opt ...RequestOption) (*ActionsListRunnerApplicationsForRepoResponse, error) {
	return ActionsListRunnerApplicationsForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsListRunnerApplicationsForRepoReq is request data for Client.ActionsListRunnerApplicationsForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
type ActionsListRunnerApplicationsForRepoReq struct {
	_url  string
	Owner string
	Repo  string
}

func (r *ActionsListRunnerApplicationsForRepoReq) url() string {
	return r._url
}

func (r *ActionsListRunnerApplicationsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners/downloads", r.Owner, r.Repo)
}

func (r *ActionsListRunnerApplicationsForRepoReq) method() string {
	return "GET"
}

func (r *ActionsListRunnerApplicationsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsListRunnerApplicationsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListRunnerApplicationsForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsListRunnerApplicationsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListRunnerApplicationsForRepoReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListRunnerApplicationsForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-runner-applications-for-repo", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListRunnerApplicationsForRepoReq) Rel(link RelName, resp *ActionsListRunnerApplicationsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListRunnerApplicationsForRepoResponse is a response for ActionsListRunnerApplicationsForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-runner-applications-for-a-repository
*/
type ActionsListRunnerApplicationsForRepoResponse struct {
	response
	request *ActionsListRunnerApplicationsForRepoReq
	Data    []components.RunnerApplication
}

/*
ActionsListSelectedReposForOrgSecret performs requests for "actions/list-selected-repos-for-org-secret"

List selected repositories for an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
func ActionsListSelectedReposForOrgSecret(ctx context.Context, req *ActionsListSelectedReposForOrgSecretReq, opt ...RequestOption) (*ActionsListSelectedReposForOrgSecretResponse, error) {
	if req == nil {
		req = new(ActionsListSelectedReposForOrgSecretReq)
	}
	resp := &ActionsListSelectedReposForOrgSecretResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-selected-repos-for-org-secret", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ActionsListSelectedReposForOrgSecretResponseBody{}
	err = r.decodeBody(&resp.Data, "actions/list-selected-repos-for-org-secret")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListSelectedReposForOrgSecret performs requests for "actions/list-selected-repos-for-org-secret"

List selected repositories for an organization secret.

  GET /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
func (c Client) ActionsListSelectedReposForOrgSecret(ctx context.Context, req *ActionsListSelectedReposForOrgSecretReq, opt ...RequestOption) (*ActionsListSelectedReposForOrgSecretResponse, error) {
	return ActionsListSelectedReposForOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsListSelectedReposForOrgSecretReq is request data for Client.ActionsListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ActionsListSelectedReposForOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string
}

func (r *ActionsListSelectedReposForOrgSecretReq) url() string {
	return r._url
}

func (r *ActionsListSelectedReposForOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories", r.Org, r.SecretName)
}

func (r *ActionsListSelectedReposForOrgSecretReq) method() string {
	return "GET"
}

func (r *ActionsListSelectedReposForOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsListSelectedReposForOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListSelectedReposForOrgSecretReq) body() interface{} {
	return nil
}

func (r *ActionsListSelectedReposForOrgSecretReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListSelectedReposForOrgSecretReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListSelectedReposForOrgSecretReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-selected-repos-for-org-secret", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListSelectedReposForOrgSecretReq) Rel(link RelName, resp *ActionsListSelectedReposForOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListSelectedReposForOrgSecretResponseBody is a response body for ActionsListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ActionsListSelectedReposForOrgSecretResponseBody struct {
	Repositories []components.MinimalRepository `json:"repositories,omitempty"`
	TotalCount   int64                          `json:"total_count,omitempty"`
}

/*
ActionsListSelectedReposForOrgSecretResponse is a response for ActionsListSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#list-selected-repositories-for-an-organization-secret
*/
type ActionsListSelectedReposForOrgSecretResponse struct {
	response
	request *ActionsListSelectedReposForOrgSecretReq
	Data    ActionsListSelectedReposForOrgSecretResponseBody
}

/*
ActionsListSelfHostedRunnersForOrg performs requests for "actions/list-self-hosted-runners-for-org"

List self-hosted runners for an organization.

  GET /orgs/{org}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
func ActionsListSelfHostedRunnersForOrg(ctx context.Context, req *ActionsListSelfHostedRunnersForOrgReq, opt ...RequestOption) (*ActionsListSelfHostedRunnersForOrgResponse, error) {
	if req == nil {
		req = new(ActionsListSelfHostedRunnersForOrgReq)
	}
	resp := &ActionsListSelfHostedRunnersForOrgResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-self-hosted-runners-for-org", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ActionsListSelfHostedRunnersForOrgResponseBody{}
	err = r.decodeBody(&resp.Data, "actions/list-self-hosted-runners-for-org")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListSelfHostedRunnersForOrg performs requests for "actions/list-self-hosted-runners-for-org"

List self-hosted runners for an organization.

  GET /orgs/{org}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
func (c Client) ActionsListSelfHostedRunnersForOrg(ctx context.Context, req *ActionsListSelfHostedRunnersForOrgReq, opt ...RequestOption) (*ActionsListSelfHostedRunnersForOrgResponse, error) {
	return ActionsListSelfHostedRunnersForOrg(ctx, req, append(c, opt...)...)
}

/*
ActionsListSelfHostedRunnersForOrgReq is request data for Client.ActionsListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ActionsListSelfHostedRunnersForOrgReq struct {
	_url string
	Org  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListSelfHostedRunnersForOrgReq) url() string {
	return r._url
}

func (r *ActionsListSelfHostedRunnersForOrgReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/runners", r.Org)
}

func (r *ActionsListSelfHostedRunnersForOrgReq) method() string {
	return "GET"
}

func (r *ActionsListSelfHostedRunnersForOrgReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListSelfHostedRunnersForOrgReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListSelfHostedRunnersForOrgReq) body() interface{} {
	return nil
}

func (r *ActionsListSelfHostedRunnersForOrgReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListSelfHostedRunnersForOrgReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListSelfHostedRunnersForOrgReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-self-hosted-runners-for-org", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListSelfHostedRunnersForOrgReq) Rel(link RelName, resp *ActionsListSelfHostedRunnersForOrgResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListSelfHostedRunnersForOrgResponseBody is a response body for ActionsListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ActionsListSelfHostedRunnersForOrgResponseBody struct {
	Runners    []components.Runner `json:"runners,omitempty"`
	TotalCount int64               `json:"total_count,omitempty"`
}

/*
ActionsListSelfHostedRunnersForOrgResponse is a response for ActionsListSelfHostedRunnersForOrg

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-an-organization
*/
type ActionsListSelfHostedRunnersForOrgResponse struct {
	response
	request *ActionsListSelfHostedRunnersForOrgReq
	Data    ActionsListSelfHostedRunnersForOrgResponseBody
}

/*
ActionsListSelfHostedRunnersForRepo performs requests for "actions/list-self-hosted-runners-for-repo"

List self-hosted runners for a repository.

  GET /repos/{owner}/{repo}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
func ActionsListSelfHostedRunnersForRepo(ctx context.Context, req *ActionsListSelfHostedRunnersForRepoReq, opt ...RequestOption) (*ActionsListSelfHostedRunnersForRepoResponse, error) {
	if req == nil {
		req = new(ActionsListSelfHostedRunnersForRepoReq)
	}
	resp := &ActionsListSelfHostedRunnersForRepoResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-self-hosted-runners-for-repo", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ActionsListSelfHostedRunnersForRepoResponseBody{}
	err = r.decodeBody(&resp.Data, "actions/list-self-hosted-runners-for-repo")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListSelfHostedRunnersForRepo performs requests for "actions/list-self-hosted-runners-for-repo"

List self-hosted runners for a repository.

  GET /repos/{owner}/{repo}/actions/runners

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
func (c Client) ActionsListSelfHostedRunnersForRepo(ctx context.Context, req *ActionsListSelfHostedRunnersForRepoReq, opt ...RequestOption) (*ActionsListSelfHostedRunnersForRepoResponse, error) {
	return ActionsListSelfHostedRunnersForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsListSelfHostedRunnersForRepoReq is request data for Client.ActionsListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ActionsListSelfHostedRunnersForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListSelfHostedRunnersForRepoReq) url() string {
	return r._url
}

func (r *ActionsListSelfHostedRunnersForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runners", r.Owner, r.Repo)
}

func (r *ActionsListSelfHostedRunnersForRepoReq) method() string {
	return "GET"
}

func (r *ActionsListSelfHostedRunnersForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListSelfHostedRunnersForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListSelfHostedRunnersForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsListSelfHostedRunnersForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListSelfHostedRunnersForRepoReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListSelfHostedRunnersForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-self-hosted-runners-for-repo", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListSelfHostedRunnersForRepoReq) Rel(link RelName, resp *ActionsListSelfHostedRunnersForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListSelfHostedRunnersForRepoResponseBody is a response body for ActionsListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ActionsListSelfHostedRunnersForRepoResponseBody struct {
	Runners    []components.Runner `json:"runners,omitempty"`
	TotalCount int64               `json:"total_count,omitempty"`
}

/*
ActionsListSelfHostedRunnersForRepoResponse is a response for ActionsListSelfHostedRunnersForRepo

https://developer.github.com/v3/actions/self-hosted-runners/#list-self-hosted-runners-for-a-repository
*/
type ActionsListSelfHostedRunnersForRepoResponse struct {
	response
	request *ActionsListSelfHostedRunnersForRepoReq
	Data    ActionsListSelfHostedRunnersForRepoResponseBody
}

/*
ActionsListWorkflowRunArtifacts performs requests for "actions/list-workflow-run-artifacts"

List workflow run artifacts.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
func ActionsListWorkflowRunArtifacts(ctx context.Context, req *ActionsListWorkflowRunArtifactsReq, opt ...RequestOption) (*ActionsListWorkflowRunArtifactsResponse, error) {
	if req == nil {
		req = new(ActionsListWorkflowRunArtifactsReq)
	}
	resp := &ActionsListWorkflowRunArtifactsResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-workflow-run-artifacts", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ActionsListWorkflowRunArtifactsResponseBody{}
	err = r.decodeBody(&resp.Data, "actions/list-workflow-run-artifacts")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListWorkflowRunArtifacts performs requests for "actions/list-workflow-run-artifacts"

List workflow run artifacts.

  GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
func (c Client) ActionsListWorkflowRunArtifacts(ctx context.Context, req *ActionsListWorkflowRunArtifactsReq, opt ...RequestOption) (*ActionsListWorkflowRunArtifactsResponse, error) {
	return ActionsListWorkflowRunArtifacts(ctx, req, append(c, opt...)...)
}

/*
ActionsListWorkflowRunArtifactsReq is request data for Client.ActionsListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ActionsListWorkflowRunArtifactsReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListWorkflowRunArtifactsReq) url() string {
	return r._url
}

func (r *ActionsListWorkflowRunArtifactsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/artifacts", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsListWorkflowRunArtifactsReq) method() string {
	return "GET"
}

func (r *ActionsListWorkflowRunArtifactsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListWorkflowRunArtifactsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListWorkflowRunArtifactsReq) body() interface{} {
	return nil
}

func (r *ActionsListWorkflowRunArtifactsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListWorkflowRunArtifactsReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListWorkflowRunArtifactsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-workflow-run-artifacts", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListWorkflowRunArtifactsReq) Rel(link RelName, resp *ActionsListWorkflowRunArtifactsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListWorkflowRunArtifactsResponseBody is a response body for ActionsListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ActionsListWorkflowRunArtifactsResponseBody struct {
	Artifacts  []components.Artifact `json:"artifacts,omitempty"`
	TotalCount int64                 `json:"total_count,omitempty"`
}

/*
ActionsListWorkflowRunArtifactsResponse is a response for ActionsListWorkflowRunArtifacts

https://developer.github.com/v3/actions/artifacts/#list-workflow-run-artifacts
*/
type ActionsListWorkflowRunArtifactsResponse struct {
	response
	request *ActionsListWorkflowRunArtifactsReq
	Data    ActionsListWorkflowRunArtifactsResponseBody
}

/*
ActionsListWorkflowRuns performs requests for "actions/list-workflow-runs"

List workflow runs.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
func ActionsListWorkflowRuns(ctx context.Context, req *ActionsListWorkflowRunsReq, opt ...RequestOption) (*ActionsListWorkflowRunsResponse, error) {
	if req == nil {
		req = new(ActionsListWorkflowRunsReq)
	}
	resp := &ActionsListWorkflowRunsResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-workflow-runs", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ActionsListWorkflowRunsResponseBody{}
	err = r.decodeBody(&resp.Data, "actions/list-workflow-runs")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListWorkflowRuns performs requests for "actions/list-workflow-runs"

List workflow runs.

  GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
func (c Client) ActionsListWorkflowRuns(ctx context.Context, req *ActionsListWorkflowRunsReq, opt ...RequestOption) (*ActionsListWorkflowRunsResponse, error) {
	return ActionsListWorkflowRuns(ctx, req, append(c, opt...)...)
}

/*
ActionsListWorkflowRunsReq is request data for Client.ActionsListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ActionsListWorkflowRunsReq struct {
	_url       string
	Owner      string
	Repo       string
	WorkflowId int64

	/*
	Returns someone's workflow runs. Use the login for the user who created the
	`push` associated with the check suite or workflow run.
	*/
	Actor *string

	/*
	Returns workflow runs associated with a branch. Use the name of the branch of
	the `push`.
	*/
	Branch *string

	/*
	Returns workflow run triggered by the event you specify. For example, `push`,
	`pull_request` or `issue`. For more information, see "[Events that trigger
	workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
	*/
	Event *string

	/*
	Returns workflow runs associated with the check run `status` or `conclusion` you
	specify. For example, a conclusion can be `success` or a status can be
	`completed`. For more information, see the `status` and `conclusion` options
	available in "[Create a check
	run](https://developer.github.com/v3/checks/runs/#create-a-check-run)."
	*/
	Status *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListWorkflowRunsReq) url() string {
	return r._url
}

func (r *ActionsListWorkflowRunsReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/workflows/%v/runs", r.Owner, r.Repo, r.WorkflowId)
}

func (r *ActionsListWorkflowRunsReq) method() string {
	return "GET"
}

func (r *ActionsListWorkflowRunsReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Actor != nil {
		query.Set("actor", *r.Actor)
	}
	if r.Branch != nil {
		query.Set("branch", *r.Branch)
	}
	if r.Event != nil {
		query.Set("event", *r.Event)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListWorkflowRunsReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListWorkflowRunsReq) body() interface{} {
	return nil
}

func (r *ActionsListWorkflowRunsReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListWorkflowRunsReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListWorkflowRunsReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-workflow-runs", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListWorkflowRunsReq) Rel(link RelName, resp *ActionsListWorkflowRunsResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListWorkflowRunsResponseBody is a response body for ActionsListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ActionsListWorkflowRunsResponseBody struct {
	TotalCount   int64                    `json:"total_count,omitempty"`
	WorkflowRuns []components.WorkflowRun `json:"workflow_runs,omitempty"`
}

/*
ActionsListWorkflowRunsResponse is a response for ActionsListWorkflowRuns

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs
*/
type ActionsListWorkflowRunsResponse struct {
	response
	request *ActionsListWorkflowRunsReq
	Data    ActionsListWorkflowRunsResponseBody
}

/*
ActionsListWorkflowRunsForRepo performs requests for "actions/list-workflow-runs-for-repo"

List workflow runs for a repository.

  GET /repos/{owner}/{repo}/actions/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
func ActionsListWorkflowRunsForRepo(ctx context.Context, req *ActionsListWorkflowRunsForRepoReq, opt ...RequestOption) (*ActionsListWorkflowRunsForRepoResponse, error) {
	if req == nil {
		req = new(ActionsListWorkflowRunsForRepoReq)
	}
	resp := &ActionsListWorkflowRunsForRepoResponse{request: req}
	r, err := doRequest(ctx, req, "actions/list-workflow-runs-for-repo", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	resp.Data = ActionsListWorkflowRunsForRepoResponseBody{}
	err = r.decodeBody(&resp.Data, "actions/list-workflow-runs-for-repo")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsListWorkflowRunsForRepo performs requests for "actions/list-workflow-runs-for-repo"

List workflow runs for a repository.

  GET /repos/{owner}/{repo}/actions/runs

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
func (c Client) ActionsListWorkflowRunsForRepo(ctx context.Context, req *ActionsListWorkflowRunsForRepoReq, opt ...RequestOption) (*ActionsListWorkflowRunsForRepoResponse, error) {
	return ActionsListWorkflowRunsForRepo(ctx, req, append(c, opt...)...)
}

/*
ActionsListWorkflowRunsForRepoReq is request data for Client.ActionsListWorkflowRunsForRepo

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
type ActionsListWorkflowRunsForRepoReq struct {
	_url  string
	Owner string
	Repo  string

	/*
	Returns someone's workflow runs. Use the login for the user who created the
	`push` associated with the check suite or workflow run.
	*/
	Actor *string

	/*
	Returns workflow runs associated with a branch. Use the name of the branch of
	the `push`.
	*/
	Branch *string

	/*
	Returns workflow run triggered by the event you specify. For example, `push`,
	`pull_request` or `issue`. For more information, see "[Events that trigger
	workflows](https://help.github.com/en/actions/automating-your-workflow-with-github-actions/events-that-trigger-workflows)."
	*/
	Event *string

	/*
	Returns workflow runs associated with the check run `status` or `conclusion` you
	specify. For example, a conclusion can be `success` or a status can be
	`completed`. For more information, see the `status` and `conclusion` options
	available in "[Create a check
	run](https://developer.github.com/v3/checks/runs/#create-a-check-run)."
	*/
	Status *string

	// Results per page (max 100)
	PerPage *int64

	// Page number of the results to fetch.
	Page *int64
}

func (r *ActionsListWorkflowRunsForRepoReq) url() string {
	return r._url
}

func (r *ActionsListWorkflowRunsForRepoReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs", r.Owner, r.Repo)
}

func (r *ActionsListWorkflowRunsForRepoReq) method() string {
	return "GET"
}

func (r *ActionsListWorkflowRunsForRepoReq) urlQuery() url.Values {
	query := url.Values{}
	if r.Actor != nil {
		query.Set("actor", *r.Actor)
	}
	if r.Branch != nil {
		query.Set("branch", *r.Branch)
	}
	if r.Event != nil {
		query.Set("event", *r.Event)
	}
	if r.Status != nil {
		query.Set("status", *r.Status)
	}
	if r.PerPage != nil {
		query.Set("per_page", strconv.FormatInt(*r.PerPage, 10))
	}
	if r.Page != nil {
		query.Set("page", strconv.FormatInt(*r.Page, 10))
	}
	return query
}

func (r *ActionsListWorkflowRunsForRepoReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"accept": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsListWorkflowRunsForRepoReq) body() interface{} {
	return nil
}

func (r *ActionsListWorkflowRunsForRepoReq) dataStatuses() []int {
	return []int{200}
}

func (r *ActionsListWorkflowRunsForRepoReq) validStatuses() []int {
	return []int{200}
}

// HTTPRequest builds an *http.Request
func (r *ActionsListWorkflowRunsForRepoReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/list-workflow-runs-for-repo", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsListWorkflowRunsForRepoReq) Rel(link RelName, resp *ActionsListWorkflowRunsForRepoResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsListWorkflowRunsForRepoResponseBody is a response body for ActionsListWorkflowRunsForRepo

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
type ActionsListWorkflowRunsForRepoResponseBody struct {
	TotalCount   int64                    `json:"total_count,omitempty"`
	WorkflowRuns []components.WorkflowRun `json:"workflow_runs,omitempty"`
}

/*
ActionsListWorkflowRunsForRepoResponse is a response for ActionsListWorkflowRunsForRepo

https://developer.github.com/v3/actions/workflow-runs/#list-workflow-runs-for-a-repository
*/
type ActionsListWorkflowRunsForRepoResponse struct {
	response
	request *ActionsListWorkflowRunsForRepoReq
	Data    ActionsListWorkflowRunsForRepoResponseBody
}

/*
ActionsReRunWorkflow performs requests for "actions/re-run-workflow"

Re-run a workflow.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
func ActionsReRunWorkflow(ctx context.Context, req *ActionsReRunWorkflowReq, opt ...RequestOption) (*ActionsReRunWorkflowResponse, error) {
	if req == nil {
		req = new(ActionsReRunWorkflowReq)
	}
	resp := &ActionsReRunWorkflowResponse{request: req}
	r, err := doRequest(ctx, req, "actions/re-run-workflow", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/re-run-workflow")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsReRunWorkflow performs requests for "actions/re-run-workflow"

Re-run a workflow.

  POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
func (c Client) ActionsReRunWorkflow(ctx context.Context, req *ActionsReRunWorkflowReq, opt ...RequestOption) (*ActionsReRunWorkflowResponse, error) {
	return ActionsReRunWorkflow(ctx, req, append(c, opt...)...)
}

/*
ActionsReRunWorkflowReq is request data for Client.ActionsReRunWorkflow

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
type ActionsReRunWorkflowReq struct {
	_url  string
	Owner string
	Repo  string
	RunId int64
}

func (r *ActionsReRunWorkflowReq) url() string {
	return r._url
}

func (r *ActionsReRunWorkflowReq) urlPath() string {
	return fmt.Sprintf("/repos/%v/%v/actions/runs/%v/rerun", r.Owner, r.Repo, r.RunId)
}

func (r *ActionsReRunWorkflowReq) method() string {
	return "POST"
}

func (r *ActionsReRunWorkflowReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsReRunWorkflowReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsReRunWorkflowReq) body() interface{} {
	return nil
}

func (r *ActionsReRunWorkflowReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsReRunWorkflowReq) validStatuses() []int {
	return []int{201}
}

// HTTPRequest builds an *http.Request
func (r *ActionsReRunWorkflowReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/re-run-workflow", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsReRunWorkflowReq) Rel(link RelName, resp *ActionsReRunWorkflowResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsReRunWorkflowResponse is a response for ActionsReRunWorkflow

https://developer.github.com/v3/actions/workflow-runs/#re-run-a-workflow
*/
type ActionsReRunWorkflowResponse struct {
	response
	request *ActionsReRunWorkflowReq
}

/*
ActionsRemoveSelectedRepoFromOrgSecret performs requests for "actions/remove-selected-repo-from-org-secret"

Remove selected repository from an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
func ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, req *ActionsRemoveSelectedRepoFromOrgSecretReq, opt ...RequestOption) (*ActionsRemoveSelectedRepoFromOrgSecretResponse, error) {
	if req == nil {
		req = new(ActionsRemoveSelectedRepoFromOrgSecretReq)
	}
	resp := &ActionsRemoveSelectedRepoFromOrgSecretResponse{request: req}
	r, err := doRequest(ctx, req, "actions/remove-selected-repo-from-org-secret", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/remove-selected-repo-from-org-secret")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsRemoveSelectedRepoFromOrgSecret performs requests for "actions/remove-selected-repo-from-org-secret"

Remove selected repository from an organization secret.

  DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
func (c Client) ActionsRemoveSelectedRepoFromOrgSecret(ctx context.Context, req *ActionsRemoveSelectedRepoFromOrgSecretReq, opt ...RequestOption) (*ActionsRemoveSelectedRepoFromOrgSecretResponse, error) {
	return ActionsRemoveSelectedRepoFromOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsRemoveSelectedRepoFromOrgSecretReq is request data for Client.ActionsRemoveSelectedRepoFromOrgSecret

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
type ActionsRemoveSelectedRepoFromOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName string

	// repository_id parameter
	RepositoryId int64
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) url() string {
	return r._url
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories/%v", r.Org, r.SecretName, r.RepositoryId)
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) method() string {
	return "DELETE"
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) body() interface{} {
	return nil
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/remove-selected-repo-from-org-secret", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsRemoveSelectedRepoFromOrgSecretReq) Rel(link RelName, resp *ActionsRemoveSelectedRepoFromOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsRemoveSelectedRepoFromOrgSecretResponse is a response for ActionsRemoveSelectedRepoFromOrgSecret

https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret
*/
type ActionsRemoveSelectedRepoFromOrgSecretResponse struct {
	response
	request *ActionsRemoveSelectedRepoFromOrgSecretReq
}

/*
ActionsSetSelectedReposForOrgSecret performs requests for "actions/set-selected-repos-for-org-secret"

Set selected repositories for an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
func ActionsSetSelectedReposForOrgSecret(ctx context.Context, req *ActionsSetSelectedReposForOrgSecretReq, opt ...RequestOption) (*ActionsSetSelectedReposForOrgSecretResponse, error) {
	if req == nil {
		req = new(ActionsSetSelectedReposForOrgSecretReq)
	}
	resp := &ActionsSetSelectedReposForOrgSecretResponse{request: req}
	r, err := doRequest(ctx, req, "actions/set-selected-repos-for-org-secret", opt...)
	if r != nil {
		resp.response = *r
	}
	if err != nil {
		return resp, err
	}
	err = r.decodeBody(nil, "actions/set-selected-repos-for-org-secret")
	if err != nil {
		return nil, err
	}
	return resp, nil
}

/*
ActionsSetSelectedReposForOrgSecret performs requests for "actions/set-selected-repos-for-org-secret"

Set selected repositories for an organization secret.

  PUT /orgs/{org}/actions/secrets/{secret_name}/repositories

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
func (c Client) ActionsSetSelectedReposForOrgSecret(ctx context.Context, req *ActionsSetSelectedReposForOrgSecretReq, opt ...RequestOption) (*ActionsSetSelectedReposForOrgSecretResponse, error) {
	return ActionsSetSelectedReposForOrgSecret(ctx, req, append(c, opt...)...)
}

/*
ActionsSetSelectedReposForOrgSecretReq is request data for Client.ActionsSetSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type ActionsSetSelectedReposForOrgSecretReq struct {
	_url string
	Org  string

	// secret_name parameter
	SecretName  string
	RequestBody ActionsSetSelectedReposForOrgSecretReqBody
}

func (r *ActionsSetSelectedReposForOrgSecretReq) url() string {
	return r._url
}

func (r *ActionsSetSelectedReposForOrgSecretReq) urlPath() string {
	return fmt.Sprintf("/orgs/%v/actions/secrets/%v/repositories", r.Org, r.SecretName)
}

func (r *ActionsSetSelectedReposForOrgSecretReq) method() string {
	return "PUT"
}

func (r *ActionsSetSelectedReposForOrgSecretReq) urlQuery() url.Values {
	query := url.Values{}
	return query
}

func (r *ActionsSetSelectedReposForOrgSecretReq) header(requiredPreviews, allPreviews bool) http.Header {
	headerVals := map[string]*string{"content-type": String("application/json")}
	previewVals := map[string]bool{}
	return requestHeaders(headerVals, previewVals)
}

func (r *ActionsSetSelectedReposForOrgSecretReq) body() interface{} {
	return r.RequestBody
}

func (r *ActionsSetSelectedReposForOrgSecretReq) dataStatuses() []int {
	return []int{}
}

func (r *ActionsSetSelectedReposForOrgSecretReq) validStatuses() []int {
	return []int{204}
}

// HTTPRequest builds an *http.Request
func (r *ActionsSetSelectedReposForOrgSecretReq) HTTPRequest(ctx context.Context, opt ...RequestOption) (*http.Request, error) {
	return buildHTTPRequest(ctx, r, "actions/set-selected-repos-for-org-secret", opt)
}

/*
Rel updates this request to point to a relative link from resp. Returns false if
the link does not exist. Handy for paging.
*/
func (r *ActionsSetSelectedReposForOrgSecretReq) Rel(link RelName, resp *ActionsSetSelectedReposForOrgSecretResponse) bool {
	u := resp.RelLink(link)
	if u == "" {
		return false
	}
	r._url = u
	return true
}

/*
ActionsSetSelectedReposForOrgSecretReqBody is a request body for actions/set-selected-repos-for-org-secret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type ActionsSetSelectedReposForOrgSecretReqBody struct {

	/*
	An array of repository ids that can access the organization secret. You can only
	provide a list of repository ids when the `visibility` is set to `selected`. You
	can add and remove individual repositories using the [Set selected repositories
	for an organization
	secret](https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret)
	and [Remove selected repository from an organization
	secret](https://developer.github.com/v3/actions/secrets/#remove-selected-repository-from-an-organization-secret)
	endpoints.
	*/
	SelectedRepositoryIds []int64 `json:"selected_repository_ids,omitempty"`
}

/*
ActionsSetSelectedReposForOrgSecretResponse is a response for ActionsSetSelectedReposForOrgSecret

https://developer.github.com/v3/actions/secrets/#set-selected-repositories-for-an-organization-secret
*/
type ActionsSetSelectedReposForOrgSecretResponse struct {
	response
	request *ActionsSetSelectedReposForOrgSecretReq
}
